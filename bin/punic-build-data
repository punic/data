#!/usr/bin/env php
<?php

function handleError($errno, $errstr, $errfile, $errline)
{
    throw new Exception("$errstr in $errfile @ line $errline", $errno);
}
set_error_handler('handleError');

/**
 * @var string[] $argv
 */
try {
    if (isset($argv) && is_array($argv) && count($argv) > 1) {
        $optionArray = array_values($argv);
        array_shift($optionArray);
    } else {
        $optionArray = [];
    }
    $options = BuildOptions::fromArray($optionArray);
    checkEnvironment();
    echo 'Punic data format version: ', BuildOptions::FORMAT_VERSION, "\n";
    echo 'Processing CLDR version  : ', $options->getCLDRVersion(), "\n";
    if ($options->shouldUseLibphonenumber()) {
        echo 'Libphonenumber version   : ', $options->getLibphonenumberVersion(), "\n";
    }
    echo 'CLDR draft status        : ', $options->getCLDRDraftStatus(), "\n";
    echo 'Processing locales       : ', $options->describeLocales(), "\n";
    echo 'Output directory         : ', str_replace('/', DIRECTORY_SEPARATOR, $options->getOutputDirectory()), "\n";
    echo 'Temporary directory      : ', str_replace('/', DIRECTORY_SEPARATOR, $options->getTemporaryDirectory()), "\n";
    echo 'State file               : ', $options->getUpdateStateFile() ? str_replace('/', DIRECTORY_SEPARATOR, $options->getStateFile()) : '', "\n";

    $fileUtils = new FileUtils();
    $sourceData = new SourceData($options, $fileUtils);
    if ($options->getResetCLDRData()) {
        if ($sourceData->isRepositoryPresent()) {
            echo 'Deleting the repository... ';
            $sourceData->deleteRepository();
            echo "done.\n";
        }
    }
    if (!$sourceData->isRepositoryPresent()) {
        echo 'Cloning the CLDR repository... ';
        $sourceData->ensureRepositoryPresent();
        echo "done.\n";
    }
    $locales = $options->finalizeLocalesList($sourceData->getAvailableLocales());
    if (empty($locales)) {
        throw new UserMessageException('No locale will be generated');
    }
    if (!$sourceData->isJarPresent()) {
        echo 'Creating the CLDR jar file... ';
        $sourceData->ensureJarPresent();
        echo "done.\n";
    }
    if ($options->getResetCLDRData()) {
        if ($sourceData->isJsonContainerPresent()) {
            echo 'Deleting the CLDR JSON directory... ';
            $sourceData->deleteJsonContainer();
            echo "done.\n";
        }
    }
    if (!$sourceData->isJsonGenericPresent('supplemental')) {
        echo 'Creating the supplemental JSON files... ';
        $sourceData->ensureJsonGeneric('supplemental');
        echo "done.\n";
    }
    if (!$sourceData->isJsonGenericPresent('segments')) {
        echo 'Creating the segments JSON files... ';
        $sourceData->ensureJsonGeneric('segments');
        echo "done.\n";
    }
    if (!$sourceData->isJsonGenericPresent('rbnf')) {
        echo 'Creating the rbnf JSON files... ';
        $sourceData->ensureJsonGeneric('rbnf');
        echo "done.\n";
    }
    if (is_dir($options->getOutputDirectory()) && $options->getResetPunicData()) {
        echo 'Clearing current Punic data... ';
        $fileUtils->deleteFromFilesystem($options->getOutputDirectory(), true);
        echo "done.\n";
    }
    if (!$sourceData->isJsonLocalePresent('en')) {
        echo 'Building source JSON data for English... ';
        $sourceData->ensureJsonLocale('en');
        echo "done.\n";
    }
    $phpWriter = new PhpWriter($fileUtils, $options);
    $converter = new CldrConverter($fileUtils, $sourceData, $phpWriter, $options);
    $numLocales = count($locales);
    $currentLocaleIndex = 0;
    $localeFiles = [];
    foreach ($locales as $localeID) {
        echo 'Processing ', $localeID, ' (', $currentLocaleIndex + 1, '/', $numLocales, "):\n";
        $destDir = $options->getOutputDirectory() . '/' . str_replace('_', '-', $localeID);
        if (!$sourceData->isJsonLocalePresent($localeID)) {
            echo '  - building source JSON data... ';
            $sourceData->ensureJsonLocale($localeID);
            echo "done.\n";
        }
        echo '  - processing... ';
        $localeFiles = $converter->convertLocale($localeID, $destDir);
        echo "done.\n";
        $currentLocaleIndex++;
    }

    echo 'Processing supplemental files... ';
    list($supplementalFiles, $testFiles) = $converter->convertSupplemental($options->getOutputDirectory());
    echo "done.\n";

    if ($options->getUpdateStateFile()) {
        echo 'Writing state file... ';
        StateFile::write($options->getStateFile(), $options->getCLDRVersion(), $locales, $localeFiles, $supplementalFiles, $testFiles);
        echo "done.\n";
    }
    exit(0);
} catch (Exception $x) {
    echo "\n", $x->getMessage(), "\n";
    if (!$x instanceof UserMessageException) {
        echo 'FILE: ', $x->getFile(), '@', $x->getLine(), "\n";
        if (method_exists($x, 'getTraceAsString')) {
            echo "TRACE:\n", $x->getTraceAsString(), "\n";
        }
    }
    exit(1);
}

class UserMessageException extends Exception
{
}

function checkEnvironment()
{
    if (!class_exists('Collator')) {
        throw new UserMessageException('Missing PHP extension: intl');
    }
    $output = [];
    $rc = null;
    @exec('git --version 2>&1', $output, $rc);
    if ($rc !== 0) {
        throw new UserMessageException('Missing GIT command');
    }
    $output = [];
    $rc = null;
    @exec('java -version 2>&1', $output, $rc);
    if ($rc !== 0) {
        throw new UserMessageException('Missing Java JDK');
    }
    $output = [];
    $rc = null;
    @exec('ant -version 2>&1', $output, $rc);
    if ($rc !== 0) {
        throw new UserMessageException('Missing Apache ant command');
    }
}
function argToShell($arg)
{
    return preg_match('/^[\w\/:.]+$/', $arg) ? $arg : escapeshellarg($arg);
}

/**
 * Command options.
 */
class BuildOptions
{
    /**
     * The data format version: to be increased when the data structure changes (not needed if data is only added).
     *
     * @var string
     */
    const FORMAT_VERSION = '1';

    /**
     * The default CLDR version.
     *
     * @var string
     */
    const DEFAULT_CLDR_VERSION = '36';

    /**
     * The default libphonenumber version.
     *
     * @var string
     */
    const DEFAULT_LIBPHONENUMBER_VERSION = 'v8.10.22';

    /**
     * The default CLDR draft status.
     *
     * @var string
     */
    const DEFAULT_CLDR_DRAFTSTATUS = CldrDraftStatus::LEVEL_CONTRIBUTED;

    /**
     * Placeholder for all locales.
     *
     * @var string
     */
    const ALL_LOCALES_PLACEHOLDER = '[ALL]';

    /**
     * The CLDR version.
     *
     * @var string
     */
    protected $cldrVersion;

    /**
     * Get the CLDR version.
     *
     * @return string
     */
    public function getCLDRVersion()
    {
        return $this->cldrVersion;
    }

    /**
     * The libphonenumber version.
     *
     * @var string
     */
    protected $libphonenumberVersion;

    /**
     * Get the libphonenumber version.
     *
     * @return string
     */
    public function getLibphonenumberVersion()
    {
        return $this->libphonenumberVersion;
    }

    /**
     * Should we use libphonenumber instead of CLDR for telephone data?
     *
     * @return bool
     */
    public function shouldUseLibphonenumber()
    {
        return version_compare($this->getCLDRVersion(), '34') >= 0;
    }

    /**
     * The CLDR draft status.
     *
     * @var string
     */
    protected $cldrDraftStatus;

    /**
     * Get the CLDR draft status.
     *
     * @return string
     */
    public function getCLDRDraftStatus()
    {
        return $this->cldrDraftStatus;
    }

    /**
     * The CLDR version data should be reset?
     *
     * @var bool
     */
    protected $resetCLDRData;

    /**
     * The CLDR version data should be reset?
     *
     * @return bool
     */
    public function getResetCLDRData()
    {
        return $this->resetCLDRData;
    }

    /**
     * The Punic data should be reset?
     *
     * @var bool
     */
    protected $resetPunicData;

    /**
     * The Punic data should be reset?
     *
     * @return bool
     */
    public function getResetPunicData()
    {
        return $this->resetPunicData;
    }

    /**
     * Output uncompressed?
     *
     * @var bool
     */
    protected $prettyOutput;

    /**
     * Output uncompressed?
     *
     * @return bool
     */
    public function getPrettyOutput()
    {
        return $this->prettyOutput;
    }

    /**
     * The list of the output locales (or true for all).
     *
     * @var string[]|true
     */
    protected $locales;

    /**
     * The list of the locales to exclude.
     *
     * @var string[]|true
     */
    protected $excludeLocales;

    /**
     * The output directory.
     *
     * @var string
     */
    protected $outputDirectory;

    /**
     * Get the output directory.
     *
     * @return string
     */
    public function getOutputDirectory()
    {
        return $this->outputDirectory === null ? static::getDefaultOutputDirectory($this->getCLDRVersion()) : $this->outputDirectory;
    }

    /**
     * @param string|null $cldrVersion
     *
     * @return string
     */
    protected static function getDefaultOutputDirectory($cldrVersion = null)
    {
        if ($cldrVersion === null) {
            $cldrVersion = static::DEFAULT_CLDR_VERSION;
        }

        return rtrim(str_replace(DIRECTORY_SEPARATOR, '/', dirname(__DIR__)), '/') . '/docs/' . static::FORMAT_VERSION . '/' . $cldrVersion;
    }

    /**
     * The path to the state file.
     *
     * @var string
     */
    protected $stateFile;

    /**
     * Get the path to the state file.
     *
     * @return string
     */
    public function getStateFile()
    {
        return $this->stateFile;
    }

    /**
     * Get the default path to the state file.
     *
     * @return string
     */
    protected static function getDefaultStateFile()
    {
        return rtrim(str_replace(DIRECTORY_SEPARATOR, '/', dirname(__DIR__)), '/') . '/docs/state.json';
    }

    /**
     * Should the state file be created/updated?
     *
     * @var bool
     */
    protected $updateStateFile;

    /**
     * Should the state file be created/updated?
     *
     * @return bool
     */
    public function getUpdateStateFile()
    {
        return $this->updateStateFile;
    }

    /**
     * The temporary directory.
     *
     * @var string
     */
    protected $temporaryDirectory;

    /**
     * Get the temporary directory.
     *
     * @return string
     */
    public function getTemporaryDirectory()
    {
        return $this->temporaryDirectory;
    }

    /**
     * @return string
     */
    protected static function getDefaultTemporaryDirectory()
    {
        return rtrim(str_replace(DIRECTORY_SEPARATOR, '/', dirname(__DIR__)), '/') . '/temp';
    }

    /**
     * Initializes the instance.
     */
    protected function __construct()
    {
        $this->cldrVersion = static::DEFAULT_CLDR_VERSION;
        $this->libphonenumberVersion = static::DEFAULT_LIBPHONENUMBER_VERSION;
        $this->cldrDraftStatus = static::DEFAULT_CLDR_DRAFTSTATUS;
        $this->resetCLDRData = false;
        $this->resetPunicData = false;
        $this->prettyOutput = false;
        $this->locales = true;
        $this->excludeLocales = [];
        $this->outputDirectory = null;
        $this->stateFile = static::getDefaultStateFile();
        $this->updateStateFile = true;
        $this->temporaryDirectory = static::getDefaultTemporaryDirectory();
    }

    /**
     * @param array $options
     *
     * @return BuildOptions
     */
    public static function fromArray(array $options)
    {
        $result = new static();
        $localeOptions = [];
        $n = count($options);
        $matches = null;
        for ($i = 0; $i < $n; ++$i) {
            if (preg_match('/^(--[^=]+)=(.*)$/', $options[$i], $matches)) {
                $currentOption = $matches[1];
                $nextOption = $matches[2];
                $advanceNext = false;
            } else {
                $currentOption = $options[$i];
                $nextOption = $i + 1 < $n ? $options[$i + 1] : '';
                $advanceNext = true;
            }

            $optionWithValue = false;
            switch (strtolower($currentOption)) {
                case '-h':
                case '--help':
                    static::showHelp();
                    exit(0);
                case '--version':
                case '-v':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify the CLDR version to be processed');
                    }
                    if (!preg_match('/^[1-9]\d*(\.\d+)*(\.[dM]\d+|\.beta\.\d+)?$/', $nextOption)) {
                        throw new UserMessageException("Invalid version specified ($nextOption)");
                    }
                    $result->cldrVersion = $nextOption;
                    break;
                case '--libphonenumber-version':
                case '-w':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify the libphonenumber version to be processed');
                    }
                    if (!preg_match('/^v[1-9]\d*(\.\d+)*$/', $nextOption)) {
                        throw new UserMessageException("Invalid libphonenumber version specified ($nextOption)");
                    }
                    $result->libphonenumberVersion = $nextOption;
                    break;
                case '--draft-status':
                case '-d':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify the draft status');
                    }
                    $allDraftStatuses = CldrDraftStatus::getAllStatuses();
                    if (!in_array($nextOption, $allDraftStatuses, true)) {
                        throw new UserMessageException("'{$nextOption}' is not a valid CLDR draft status. Valid valus are: " . implode(', ', $allDraftStatuses));
                    }
                    $result->cldrDraftStatus = $nextOption;
                    break;
                case '--locale':
                case '-l':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify one or more locale identifiers');
                    }
                    $localeOptions = array_merge($localeOptions, explode(',', $nextOption));
                    break;
                case '--reset-cldr-data':
                case '-c':
                    $result->resetCLDRData = true;
                    break;
                case '--reset-punic-data':
                case '-r':
                    $result->resetPunicData = true;
                    break;
                case '--pretty-output':
                case '-p':
                    $result->prettyOutput = true;
                    break;
                case '--output':
                case '-o':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify the output directory');
                    }
                    $s = static::normalizeDirectoryPath($nextOption);
                    if ($s === null) {
                        throw new UserMessageException("$currentOption is not a valid output directory path");
                    }
                    $result->outputDirectory = $s;
                    break;
                case '--temp':
                case '-t':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify the temporary directory');
                    }
                    $s = static::normalizeDirectoryPath($nextOption);
                    if ($s === null) {
                        throw new UserMessageException("$currentOption is not a valid temporary directory path");
                    }
                    $result->temporaryDirectory = $s;
                    break;
                case '--no-write-state':
                    $result->updateStateFile = false;
                    break;
                case '--state-file':
                    $optionWithValue = true;
                    if ($nextOption === '') {
                        throw new UserMessageException('Please specify the path of the state file');
                    }
                    $s = static::normalizeDirectoryPath($nextOption);
                    if ($s === null) {
                        throw new UserMessageException("$currentOption is not a valid state file path");
                    }
                    $result->stateFile = $s;
                    break;
                default:
                    throw new UserMessageException("Unknown option: $currentOption\nUse -h (or --help) to get the list of available options");
            }
            if ($optionWithValue && $advanceNext) {
                ++$i;
            }
        }
        if (!empty($localeOptions)) {
            $result->parseLocaleOptions($localeOptions);
        }

        return $result;
    }

    /**
     * @param string|mixed $path
     *
     * @return string|null
     */
    protected static function normalizeDirectoryPath($path)
    {
        $result = null;
        if (is_string($path)) {
            $path = str_replace(DIRECTORY_SEPARATOR, '/', $path);
            if (stripos(PHP_OS, 'WIN') === 0) {
                $invalidChars = implode('', array_map('chr', range(0, 31))) . '*?"<>|';
            } else {
                $invalidChars = '';
            }
            $path = rtrim($path, '/');
            if ($path !== '' && $invalidChars === '' || strpbrk($path, $invalidChars) === false) {
                $result = $path;
            }
        }

        return $result;
    }

    /**
     * @param array $localeOptions
     *
     * @throws Exception
     */
    protected function parseLocaleOptions(array $localeOptions)
    {
        $allLocales = false;
        $locales = [];
        foreach ($localeOptions as $localeOption) {
            if ($localeOption === '') {
                throw new UserMessageException('Empty locale detected');
            }
            if ($localeOption === 'root') {
                $localeOption = 'en_US';
            } elseif ($localeOption === static::ALL_LOCALES_PLACEHOLDER) {
                $allLocales = true;
            } else {
                $localeOperation = '=';
                $localeCode = $localeOption;
                if ($localeOption !== '') {
                    switch ($localeOption[0]) {
                        case '+':
                        case '-':
                            $localeOperation = $localeOption[0];
                            $localeCode = substr($localeOption, 1);
                            break;
                    }
                }
                $locale = LocaleIdentifier::fromString($localeCode);
                if ($locale === null) {
                    throw new UserMessageException("Invalid locale identifier specified: $localeOption");
                }
                $localeCode = (string) $locale;
                if (isset($locales[$localeCode])) {
                    throw new UserMessageException("Locale identifier specified more than once: $localeCode");
                }
                $locales[$localeCode] = $localeOperation;
            }
        }
        if ($allLocales) {
            $this->locales = true;
            if (in_array('=', $locales)) {
                throw new UserMessageException("You specified to use all the locales, and to use specific locales.\nIf you want to specify 'all locales except some', please prepend them with a minus sign.");
            }
            $this->excludeLocales = array_keys(array_filter(
                $locales,
                function ($operation) {
                    return $operation === '-';
                }
                ));
        } else {
            if (in_array('=', $locales)) {
                $this->locales = array_keys(array_filter(
                    $locales,
                    function ($operation) {
                        return $operation !== '-';
                    }
                    ));
            } else {
                $this->locales = array_values(array_unique(array_merge(
                    $this->locales,
                    array_keys(array_filter(
                        $locales,
                        function ($operation) {
                            return $operation === '+';
                        }
                        ))
                    )));
            }
            $this->excludeLocales = array_keys(array_filter(
                $locales,
                function ($operation) {
                    return $operation === '-';
                }
                ));
        }
        if ($this->locales !== true && !empty($this->excludeLocales)) {
            $common = array_intersect($this->locales, $this->excludeLocales);
            if (!empty($common)) {
                $this->locales = array_values(array_diff($this->locales, $common));
            }
            $this->excludeLocales = [];
        }
    }

    /**
     * @return string
     */
    public function describeLocales()
    {
        if ($this->locales === true) {
            if (empty($this->excludeLocales)) {
                $result = 'all locales';
            } else {
                $result = 'all locales except ' . implode(', ', $this->excludeLocales);
            }
        } else {
            $result = implode(', ', $this->locales);
        }

        return $result;
    }

    protected static function showHelp()
    {
        $defaultCLDRVersion = static::DEFAULT_CLDR_VERSION;
        $defaultLibphonenumberVersion = static::DEFAULT_LIBPHONENUMBER_VERSION;
        $allLocalesPlaceholders = static::ALL_LOCALES_PLACEHOLDER;
        $defaultOutputDirectory = str_replace('/', DIRECTORY_SEPARATOR, static::getDefaultOutputDirectory('<CLDR-VERSION>'));
        $defaultStateFile = str_replace('/', DIRECTORY_SEPARATOR, static::getDefaultStateFile());
        $defaultTemporaryDirectory = str_replace('/', DIRECTORY_SEPARATOR, static::getDefaultTemporaryDirectory());
        $cldrDraftStatuses = implode('|', CldrDraftStatus::getAllStatuses());
        $cldrDefaultDraftStatus = static::DEFAULT_CLDR_DRAFTSTATUS;
        echo <<<EOT
Available options:

  --help|-h
    Show this help message

  --version=<version>|-v <version>
    Set the CLDR version to work on (default: $defaultCLDRVersion)
    Examples: 31.d02  30.0.3  30  29.beta.1  25.M1  23.1.d01

  --libphonenumber-version=<version>| -w <version>
    Set the libphonenumber version to work on when using CLDR 34+ (default: $defaultLibphonenumberVersion)

  --draft-status|-d <$cldrDraftStatuses>
    The minimum level of the draft status of the CLDR data to be accepted (default: $cldrDefaultDraftStatus)

  --reset-punic-data|-r
    Reset the destination Punic data before the execution

  --pretty-output|-p
    Generated expanded (uncompressed) PHP

  --output|-o
    Set the output directory (default: $defaultOutputDirectory)

  --temp|-t
    Set the temporary directory (default: $defaultTemporaryDirectory)

  --locale=<locales>|-l <locales>
    Set the locales to work on.
    It's a comman-separated list of locale codes (you can also specify this option multiple times).
    You can use $allLocalesPlaceholders (case-sensitive) to include all available locales.
    You can prepend a minus sign to substract specific locales: so for instance
    --locale=-it,-de
    means 'the default locales except Italian and German'.
    Likewise:
    --locale=ALL,-it,-de
    means 'all locales except Italian and German'.
    You can prepend a plus to add specific locales: so for instance
    --locale=+it,+de
    means 'default locales plus Italian and German'.
    By default, all locales are built.

  --no-write-state
    Don't create/update a state file.

  --state-file
    Set the path of the state file (default: $defaultStateFile)
EOT;
    }

    /**
     * @param string[] $availableLocales
     *
     * @throws Exception
     *
     * @return string[]
     */
    public function finalizeLocalesList(array $availableLocales)
    {
        if ($this->locales === true) {
            $locales = $availableLocales;
        } else {
            foreach ($this->locales as $testLocale) {
                $bl = LocaleIdentifier::fromString($testLocale);
                if (in_array($bl->getLanguage(), $availableLocales) === false) {
                    throw new UserMessageException("The locale $testLocale is not defined in the CLDR data");
                }
            }
            $locales = $this->locales;
        }
        if (!empty($this->excludeLocales)) {
            $locales = array_diff($locales, $this->excludeLocales);
        }
        natcasesort($locales);

        return array_values($locales);
    }
}

class FileUtils
{
    /**
     * @param string $path
     * @param bool $emptyOnlyDir
     *
     * @throws Exception
     */
    public function deleteFromFilesystem($path, $emptyOnlyDir = false)
    {
        $maxRetries = 5;
        if (is_file($path) || is_link($path)) {
            for ($i = 1;; $i++) {
                if (@unlink($path) === false) {
                    if ($i === $maxRetries) {
                        throw new Exception("Failed to delete the file $path");
                    }
                } else {
                    break;
                }
            }
        } elseif (is_dir($path)) {
            $contents = @scandir($path);
            if ($contents === false) {
                throw new Exception("Failed to retrieve the contents of the directory $path");
            }
            foreach (array_diff($contents, ['.', '..']) as $item) {
                $this->deleteFromFilesystem($path . '/' . $item);
            }
            if (!$emptyOnlyDir) {
                for ($i = 1;; $i++) {
                    if (@rmdir($path) === false) {
                        if ($i === $maxRetries) {
                            throw new Exception("Failed to delete the directory $path");
                        }
                    } else {
                        break;
                    }
                }
            }
        }
    }

    /**
     * @param string $path
     *
     * @throws Exception
     */
    public function createDirectory($path)
    {
        if (!is_dir($path)) {
            if (@mkdir($path, 0777, true) !== true) {
                throw new Exception("Failed to create the directory $path");
            }
        }
    }

    /**
     * @param string $path
     *
     * @throws Exception
     */
    public function createFileDirectory($path)
    {
        $this->createDirectory(dirname($path));
    }
}

class SourceData
{
    /**
     * @var BuildOptions
     */
    protected $options;

    /**
     * @return BuildOptions
     */
    public function getOptions()
    {
        return $this->options;
    }

    /**
     * @var FileUtils
     */
    protected $fileUtils;

    /**
     * @var string[]|null
     */
    protected $availableLocales;

    /**
     * @param BuildOptions $options
     */
    public function __construct(BuildOptions $options, FileUtils $fileUtils)
    {
        $this->options = $options;
        $this->fileUtils = $fileUtils;
        $this->availableLocales = null;
    }

    /**
     * Get the repository directory path.
     *
     * @return string
     */
    public function getRepositoryDirectory()
    {
        return $this->options->getTemporaryDirectory() . '/cldr/' . $this->options->getCLDRVersion() . '/repository';
    }

    /**
     * There's a local clone of the repository?
     *
     * @return bool
     */
    public function isRepositoryPresent()
    {
        return is_dir($this->getRepositoryDirectory());
    }

    /**
     * Delete the local clone of the repository.
     */
    public function deleteRepository()
    {
        $this->fileUtils->deleteFromFilesystem($this->getRepositoryDirectory());
        $this->availableLocales = null;
    }

    /**
     * Be sure that there's a local clone of the repository.
     *
     * @throws Exception
     */
    public function ensureRepositoryPresent()
    {
        if (!$this->isRepositoryPresent()) {
            $dir = $this->getRepositoryDirectory();
            $this->fileUtils->createDirectory($dir);
            $this->fileUtils->deleteFromFilesystem($dir);
            try {
                $tag = 'release-' . str_replace('.', '-', $this->options->getCLDRVersion());
                $output = [];
                $rc = null;
                @exec('git clone  --depth 1 --single-branch --depth 1 --branch ' . argToShell($tag) . ' -- https://github.com/unicode-org/cldr.git ' . argToShell($dir) . ' 2>&1', $output, $rc);
                if ($rc === 0) {
                    if (!is_dir($dir)) {
                        $rc = -1;
                    }
                }
                if ($rc !== 0) {
                    throw new Exception("Error $rc!\nError details:\n" . implode("\n", $output));
                }
                $patchFile = str_replace('/', DIRECTORY_SEPARATOR, dirname(dirname(__FILE__)) . '/patch/cldr/' . $this->getOptions()->getCLDRVersion() . '.patch');
                if (is_file($patchFile)) {
                    @exec('git -C ' . argToShell($dir) . ' apply ' . argToShell($patchFile) . ' 2>&1', $output, $rc);
                    if ($rc !== 0) {
                        throw new Exception("Error $rc!\nError details:\n" . implode("\n", $output));
                    }
                }
            } catch (Exception $x) {
                try {
                    $this->deleteRepository();
                } catch (Exception $foo) {
                }
                throw $x;
            }
        }
    }

    /**
     * Get the list of available locale IDs.
     *
     * @throws Exception
     *
     * @return string[]
     */
    public function getAvailableLocales()
    {
        if ($this->availableLocales === null) {
            $this->ensureRepositoryPresent();
            $dir = $this->getRepositoryDirectory() . '/common/main';
            if (!is_dir($dir)) {
                throw new Exception("Unable to find the directory $dir");
            }
            $contents = @scandir($dir);
            if ($contents === false) {
                throw new Exception("Failed to retrieve the contents of the directory $dir");
            }
            $availableLocales = [];
            $matches = null;
            foreach ($contents as $item) {
                if (preg_match('/^(.+)\.xml$/', $item, $matches)) {
                    $localeID = $matches[1];
                    if ($localeID === 'root' || preg_match('/^([a-z]{2,3})(?:_([A-Z][a-z]{3}))?(?:_([A-Z]{2}|[0-9]{3}))?$/', $localeID)) {
                        if (!in_array($localeID, $availableLocales, true)) {
                            $availableLocales[] = $localeID;
                            if (strpos($localeID, '_') !== false) {
                                list($languageID) = explode('_', $localeID);
                                if (!in_array($languageID, $availableLocales, true)) {
                                    $availableLocales[] = $languageID;
                                }
                            }
                        }
                    }
                }
            }
            if (empty($availableLocales)) {
                throw new Exception("No locales found in $dir");
            }
            natcasesort($availableLocales);
            $this->availableLocales = array_values($availableLocales);
        }

        return $this->availableLocales;
    }

    /**
     * Get the jar file path.
     *
     * @return string
     */
    protected function getJarFile()
    {
        return $this->getRepositoryDirectory() . '/tools/java/cldr.jar';
    }

    /**
     * Does the CLDR jar file exist?
     *
     * @return bool
     */
    public function isJarPresent()
    {
        return is_file($this->getJarFile());
    }

    /**
     * Delete the CLDR jar.
     */
    public function deleteJar()
    {
        $this->fileUtils->deleteFromFilesystem($this->getJarFile());
    }

    /**
     * Be sure that the CLDR jar file exists.
     *
     * @throws Exception
     */
    public function ensureJarPresent()
    {
        if (!$this->isJarPresent()) {
            $this->ensureRepositoryPresent();
            $file = $this->getJarFile();
            try {
                $output = [];
                $rc = null;
                @exec('ant -f ' . argToShell($this->getRepositoryDirectory() . '/tools/java/build.xml') . ' jar 2>&1', $output, $rc);
                if ($rc === 0) {
                    if (!is_file($file)) {
                        $rc = -1;
                    }
                }
                if ($rc !== 0) {
                    throw new Exception("Error $rc!\nError details:\n" . implode("\n", $output));
                }
            } catch (Exception $x) {
                try {
                    $this->deleteJar();
                } catch (Exception $foo) {
                }
                throw $x;
            }
        }
    }

    /**
     * Get the JSON directory path.
     *
     * @return string
     */
    protected function getJsonDirectory()
    {
        return $this->options->getTemporaryDirectory() . '/cldr/' . $this->options->getCLDRVersion() . '/json-' . $this->options->getCLDRDraftStatus();
    }

    /**
     * Does the JSON directory is present?
     *
     * @return bool
     */
    public function isJsonContainerPresent()
    {
        return is_dir($this->getJsonDirectory());
    }

    /**
     * Delete the JSON directory.
     */
    public function deleteJsonContainer()
    {
        $this->fileUtils->deleteFromFilesystem($this->getJsonDirectory());
        $this->availableLocales = null;
    }

    /**
     * Get the JSON directory path for a specific locale.
     *
     * @param string $localeID
     *
     * @return string
     */
    public function getJsonDirectoryForLocale($localeID)
    {
        return $this->getJsonDirectory() . '/locales/' . $localeID;
    }

    /**
     * Does the JSON directory is present for a specific locale?
     *
     * @param string $localeID
     *
     * @return bool
     */
    public function isJsonLocalePresent($localeID)
    {
        return is_dir($this->getJsonDirectoryForLocale($localeID));
    }

    /**
     * Be sure that the JSON data for a locale is there.
     *
     * @param string $localeID
     *
     * @throws Exception
     */
    public function ensureJsonLocale($localeID)
    {
        if (!$this->isJsonLocalePresent($localeID)) {
            $this->ensureJarPresent();
            $dir = $this->getJsonDirectoryForLocale($localeID);
            $this->fileUtils->createDirectory($dir);
            $this->fileUtils->deleteFromFilesystem($dir);
            $genDir = version_compare($this->getOptions()->getCLDRVersion(), '38') >= 0 ? dirname($dir) : $dir;
            try {
                $cmd = 'java';
                $cmd .= ' -Duser.language=en -Duser.country=US'; // http://unicode.org/cldr/trac/ticket/10044
                $cmd .= ' -DCLDR_DIR=' . argToShell($this->getRepositoryDirectory()); //  where the CLDR data is located
                $cmd .= ' -DCLDR_GEN_DIR=' . argToShell($genDir); // where to save the generated files
                $cmd .= ' -jar ' . argToShell($this->getJarFile()); // the CLDR jar file
                $cmd .= ' ldml2json';
                $cmd .= ' -t main'; // (main|supplemental|segments|rbnf) Type of CLDR data being generated, main, supplemental, or segments.
                $cmd .= ' -r true'; // (true|false) Whether the output JSON for the main directory should be based on resolved or unresolved data
                $cmd .= ' -s ' . argToShell($this->options->getCLDRDraftStatus()); // The minimum draft status of the output data
                $cmd .= ' -m ' . argToShell(str_replace('-', '_', $localeID)); // Regular expression to define only specific locales or files to be generated
                $output = [];
                $rc = null;
                @exec($cmd . ' 2>&1', $output, $rc);
                if ($rc === 0) {
                    if (!is_dir($dir)) {
                        $rc = -1;
                    }
                }
                if ($rc !== 0) {
                    throw new Exception("Error $rc: " . implode("\n", $output));
                }
            } catch (Exception $x) {
                try {
                    $this->fileUtils->deleteFromFilesystem($dir);
                } catch (Exception $foo) {
                }
                throw $x;
            }
        }
    }

    /**
     * Get the JSON directory path for a generic data.
     *
     * @param string $genericID (supplemental, segments)
     *
     * @return string
     */
    public function getJsonDirectoryForGeneric($genericID)
    {
        return $this->getJsonDirectory() . '/' . $genericID;
    }

    /**
     * Does the JSON directory is present for a specific generic data?
     *
     * @param string $genericID (supplemental, segments)
     *
     * @return bool
     */
    public function isJsonGenericPresent($genericID)
    {
        return is_dir($this->getJsonDirectoryForGeneric($genericID));
    }

    /**
     * Be sure that the JSON data for a generic data is there.
     *
     * @param string $genericID (supplemental, segments)
     *
     * @throws Exception
     */
    public function ensureJsonGeneric($genericID)
    {
        if (!$this->isJsonGenericPresent($genericID)) {
            $this->ensureJarPresent();
            $dir = $this->getJsonDirectoryForGeneric($genericID);
            $this->fileUtils->createDirectory($dir);
            $this->fileUtils->deleteFromFilesystem($dir);
            try {
                $cmd = 'java';
                $cmd .= ' -Duser.language=en -Duser.country=US'; // http://unicode.org/cldr/trac/ticket/10044
                $cmd .= ' -DCLDR_DIR=' . argToShell($this->getRepositoryDirectory()); //  where the CLDR data is located
                $cmd .= ' -DCLDR_GEN_DIR=' . argToShell($dir); // where to save the generated files
                $cmd .= ' -jar ' . argToShell($this->getJarFile()); // the CLDR jar file
                $cmd .= ' ldml2json';
                $cmd .= ' -s ' . argToShell($this->options->getCLDRDraftStatus()); // The minimum draft status of the output data
                switch ($genericID) {
                    case 'rbnf':
                    case 'supplemental':
                    case 'segments':
                        $cmd .= ' -o true'; // (true|false) Whether to write out the 'other' section, which contains any unmatched paths
                        $cmd .= ' -t ' . $genericID; // (main|supplemental|segments|rbnf) Type of CLDR data being generated, main, supplemental, or segments.
                        break;
                    default:
                        throw new Exception("Unrecognized generic data ID: $genericID");
                }
                $output = [];
                $rc = null;
                @exec($cmd . ' 2>&1', $output, $rc);
                if ($rc === 0) {
                    if (!is_dir($dir)) {
                        $rc = -1;
                    }
                }
                if ($rc !== 0) {
                    throw new Exception("Error $rc: " . implode("\n", $output));
                }
            } catch (Exception $x) {
                try {
                    $this->fileUtils->deleteFromFilesystem($dir);
                } catch (Exception $foo) {
                }
                throw $x;
            }
        }
    }
}

class LocaleIdentifier
{
    /**
     * @var string
     */
    protected $language = '';

    /**
     * @return string
     */
    public function getLanguage()
    {
        return $this->language;
    }

    /**
     * @var string
     */
    protected $script = '';

    /**
     * @var string
     */
    protected $region = '';

    /**
     * @var string
     */
    protected $variants = [];

    protected function __construct()
    {
    }

    /**
     * @param string|mixed $localeIdentifier
     *
     * @return static|null
     */
    public static function fromString($localeIdentifier)
    {
        $result = null;
        // http://unicode.org/reports/tr35/#Unicode_language_identifier
        if (strcasecmp($localeIdentifier, 'root') === 0) {
            $result = new static();
            $result->language = 'root';
        } else {
            $rxLanguage = '(?:[a-z]{2,3})|(?:[a-z]{5,8}:)';
            $rxScript = '[a-z]{4}';
            $rxRegion = '(?:[a-z]{2})|(?:[0-9]{3})';
            $rxVariant = '(?:[a-z0-9]{5,8})|(?:[0-9][a-z0-9]{3})';
            $rxSep = '[-_]';
            $matches = null;
            if (is_string($localeIdentifier) && preg_match("/^($rxLanguage)(?:$rxSep($rxScript))?(?:$rxSep($rxRegion))?((?:$rxSep(?:$rxVariant))*)$/i", $localeIdentifier, $matches)) {
                $result = new static();
                $result->language = strtolower($matches[1]);
                if (isset($matches[2])) {
                    $result->script = ucfirst(strtolower($matches[2]));
                }
                if (isset($matches[3])) {
                    $result->region = strtoupper($matches[3]);
                }
                if ($matches[4] !== '') {
                    $result->variants = explode('_', strtoupper(str_replace('-', '_', substr($matches[4], 1))));
                }
            }
        }

        return $result;
    }

    protected static function merge($language, $script = '', $region = '', array $variants = [])
    {
        $parts = [];

        $parts[] = $language;
        if ($script !== '') {
            $parts[] = $script;
        }
        if ($region !== '') {
            $parts[] = $region;
        }
        $parts = array_merge($parts, $variants);

        return implode('_', $parts);
    }

    /**
     * @return string
     */
    public function __toString()
    {
        return static::merge($this->language, $this->script, $this->region, $this->variants);
    }

    /**
     * @return string[]
     */
    public function getParentLocaleIdentifiers()
    {
        $parents = [];
        if (!empty($this->variants)) {
            $parents[] = static::merge($this->language, $this->script, $this->region);
        }
        if ($this->script !== '' && $this->region !== '') {
            $parents[] = static::merge($this->language, $this->script, '');
            $parents[] = static::merge($this->language, '', $this->region);
        }
        if ($this->script !== '' || $this->region !== '') {
            $parents[] = static::merge($this->language);
        }

        $parents[] = 'root';

        return $parents;
    }
}

class PhpWriter
{
    /**
     * @var FileUtils
     */
    protected $fileUtils;

    /**
     * @var BuildOptions
     */
    protected $options;

    /**
     * @param FileUtils $fileUtils
     * @param BuildOptions $options
     */
    public function __construct(FileUtils $fileUtils, BuildOptions $options)
    {
        $this->fileUtils = $fileUtils;
        $this->options = $options;
    }

    /**
     * Save data to file in PHP format.
     *
     * @param array $data
     * @param string $file
     *
     * @throws Exception
     */
    public function save(array $data, $file)
    {
        if (@is_file($file)) {
            $this->fileUtils->deleteFromFilesystem($file);
        }
        $php = "<?php\n// This file is auto-generated. Do not edit!\nreturn " . $this->phpEncode($data) . ";\n";
        if (@file_put_contents($file, $php) === false) {
            throw new Exception("Failed write to $file");
        }
    }

    protected function phpEncode($data, $indent = 0, $isArrayKey = false)
    {
        static $tabWidth = 4;
        static $minInt32 = -2147483648; // -1 * (2 ^ (32 - 1))
        static $maxInt32 = 2147483647; // 2 ^ (32 - 1) - 1
        $prettyOutput = $this->options->getPrettyOutput();
        $space = $prettyOutput ? ' ' : '';
        $type = gettype($data);
        switch (gettype($data)) {
            case 'boolean':
                $result = $data ? 'true' : 'false';
                break;
            case 'string':
                $result = "'" . addcslashes($data, "'\\") . "'";
                break;
            case 'NULL':
                $result = 'null';
                break;
            case 'double':
                $string = (string) $data;
                if ($isArrayKey) {
                    $integer = (int) $data;
                    if ($integer === $string && (PHP_INT_SIZE <= 4 || ($integer >= $minInt32 && $integer <= $maxInt32))) {
                        $result = $string;
                    } else {
                        $result = "'$string'";
                    }
                } else {
                    $result = $string;
                }
                break;
            case 'integer':
                $string = (string) $data;
                if ($isArrayKey && PHP_INT_SIZE > 4 && ($data < $minInt32 || $data > $maxInt32)) {
                    $result = "'{$string}'";
                } else {
                    $result = $string;
                }
                break;
            case 'array':
                $result = 'array(';
                $index = 0;
                $assoc = array_keys($data) !== range(0, count($data) - 1);
                foreach ($data as $key => $value) {
                    if ($index++ !== 0) {
                        $result .= ',';
                    }
                    if ($prettyOutput) {
                        $result .= "\n" . str_repeat($space, $indent + $tabWidth);
                    }
                    if ($assoc) {
                        $result .= $this->phpEncode($key, 0, true) . $space . '=>' . $space;
                    }
                    $result .= $this->phpEncode($value, $indent + $tabWidth);
                }
                if ($prettyOutput) {
                    $result .= "\n" . str_repeat($space, $indent);
                }
                $result .= ')';
                break;
            default:
                throw new Exception("Unsupported type: {$type}");
        }

        return $result;
    }
}

class CldrConverter
{
    /**
     * @var FileUtils
     */
    protected $fileUtils;

    /**
     * @var SourceData
     */
    protected $sourceData;

    /**
     * @var PhpWriter
     */
    protected $phpWriter;

    /**
     * @var BuildOptions
     */
    protected $options;

    /**
     * @param FileUtils $fileUtils
     * @param SourceData $sourceData
     * @param PhpWriter $phpWriter
     */
    public function __construct(FileUtils $fileUtils, SourceData $sourceData, PhpWriter $phpWriter, BuildOptions $options)
    {
        $this->fileUtils = $fileUtils;
        $this->sourceData = $sourceData;
        $this->phpWriter = $phpWriter;
        $this->options = $options;
    }

    /**
     * Convert the CLDR JSON data into Punic data for a specific locale.
     *
     * @param string $localeID
     * @param string $destinationDirectory
     *
     * @throws Exception
     *
     * @return string[]
     */
    public function convertLocale($localeID, $destinationDirectory)
    {
        $this->fileUtils->createDirectory($destinationDirectory);

        $destinationFiles = [];
        try {
            $converters = [
                new CalendarLocalePunicConversion(),
                new TimeZoneNameslocalePunicConversion(),
                new ListPatternsLocalePunicConversion(),
                new UnitsLocalePunicConversion(),
                new NoopLocalePunicConversion(['dates', 'fields'], 'dateFields'),
                new LanguagesLocalePunicConversion(),
                new NoopLocalePunicConversion(['localeDisplayNames', 'territories']),
                new LocaleDisplayNamesLocalePunicConversion(),
                new NumbersLocalePunicConversion(),
                new NoopLocalePunicConversion(['layout', 'orientation'], 'layout'),
                new NoopLocalePunicConversion(['localeDisplayNames', 'measurementSystemNames']),
                new CurrenciesLocalePunicConversion(),
                new RbnfLocalePunicConversion(),
            ];
            if (version_compare($this->options->getCLDRVersion(), '32') >= 0) {
                $converters[] = new SubdivisionsLocalePunicConversion($destinationDirectory . '/localeDisplayNames.php');
            }

            foreach ($converters as $converter) {
                $destinationFile = $destinationDirectory . '/' . $converter->getIdentifier() . '.php';
                $destinationFiles[] = $destinationFile;
                if (!is_file($destinationFile)) {
                    $data = $converter->convert($this->sourceData, $localeID);
                    $this->phpWriter->save($data, $destinationFile);

                    if ($converter->getIdentifier() === 'currencies' && $localeID !== 'en') {
                        $this->copyMissingData_currency(
                            $destinationDirectory . '/currencies.php'
                        );
                    }
                }
            }
        } catch (Exception $x) {
            $this->fileUtils->deleteFromFilesystem($destinationDirectory);
            throw $x;
        }

        return $destinationFiles;
    }

    /**
     * Convert the supplemental CLDR JSON data into Punic data.
     *
     * @param string $destinationDirectory
     *
     * @throws Exception
     *
     * @return string[][]
     */
    public function convertSupplemental($destinationDirectory)
    {
        $converters = [
            new TerritoryInfoSupplementalPunicConversion(),
            new TimeDataSupplementalPunicConversion(),
            new DayPeriodsSupplementalPunicConversion(),
            new WeekDataSupplementalPunicConversion(),
            new NoopSupplementalPunicConversion(['supplemental', 'parentLocales', 'parentLocale'], 'parentLocales'),
            new NoopSupplementalPunicConversion(['supplemental', 'likelySubtags']),
            new TerritoryContainmentSupplementalPunicConversion(),
            new MetaZonesSupplementalPunicConversion(),
            new NoopSupplementalPunicConversion(['supplemental', 'primaryZones']),
            new PluralsSupplementalPunicConversion('cardinal', 'plurals'),
            new PluralsSupplementalPunicConversion('ordinal', 'ordinals'),
            new MeasurementDataSupplementalPunicConversion(),
            new CurrencyDataSupplementalPunicConversion(),
        ];
        if (version_compare($this->options->getCLDRVersion(), '32') >= 0) {
            $converters[] = new SubdivisionsSupplementalPunicConversion();
            $converters[] = new TimeZoneSupplementalPunicConversion();
            $converters[] = new CodeMappingsSupplementalPunicConversion();
        }
        if ($this->options->shouldUseLibphonenumber()) {
            $converters[] = new TelephoneCodeDataLibphonenumberPunicConversion();
        } else {
            $converters[] = new TelephoneCodeDataSupplementalPunicConversion();
        }

        $supplementalFiles = [];
        $testFiles = [];
        foreach ($converters as $converter) {
            $destinationFile = $destinationDirectory . '/' . $converter->getIdentifier() . '.php';
            $supplementalFiles[] = $destinationFile;
            if (!is_file($destinationFile)) {
                $data = $converter->convert($this->sourceData);
                $this->phpWriter->save($data, $destinationFile);
            }
            if ($converter instanceof PluralsSupplementalPunicConversion && $converter->getIdentifier() === 'plurals') {
                $destinationFile = $destinationDirectory . '/__test.plurals.php';
                $testFiles[] = $destinationFile;
                if (!is_file($destinationFile)) {
                    $data = $converter->convertTestData($this->sourceData);
                    $this->phpWriter->save($data, $destinationFile);
                }
            }
        }

        return [$supplementalFiles, $testFiles];
    }

    /**
     * @param array $symbols
     * @param string $isoPattern
     *
     * @throws Exception
     *
     * @return string[]
     */
    private function numberFormatToRegularExpressions(array $symbols, $isoPattern)
    {
        $p = explode(';', $isoPattern);
        $patterns = [
            '+' => $p[0],
            '-' => (count($p) == 1) ? "-{$p[0]}" : $p[1],
        ];
        $result = [];
        $m = null;
        foreach ($patterns as $patternKey => $pattern) {
            $rxPost = $rxPre = '';
            if (preg_match('/(-)?([^0#E,\\.\\-+]*)(.+?)([^0#E,\\.\\-+]*)(-)?$/', $pattern, $m)) {
                for ($i = 1; $i < 6; ++$i) {
                    if (!isset($m[$i])) {
                        $m[$i] = '';
                    }
                }
                if (strlen($m[2]) > 0) {
                    $rxPre = preg_quote($m[2]);
                }
                $pattern = $m[1] . $m[3] . $m[5];
                if (strlen($m[4]) > 0) {
                    $rxPost = preg_quote($m[4]);
                }
            }
            $rx = '';
            if (strpos($pattern, '.') !== false) {
                list($intPattern, $decimalPattern) = explode('.', $pattern, 2);
            } else {
                $intPattern = $pattern;
                $decimalPattern = '';
            }
            if (strpos($intPattern, 'E') !== false) {
                switch ($intPattern) {
                    case '#E0':
                    case '#E00':
                        $rx .= '(' . preg_quote($symbols['plusSign']) . ')?[0-9]+((' . preg_quote($symbols['decimal']) . ')[0-9]+)*[eE]((' . preg_quote($symbols['minusSign']) . ')|(' . preg_quote($symbols['plusSign']) . '))?[0-9]+';
                        break;
                    case '-#E0':
                    case '-#E00':
                        $rx .= '(' . preg_quote($symbols['minusSign']) . ')?[0-9]+((' . preg_quote($symbols['decimal']) . ')[0-9]+)*[eE]((' . preg_quote($symbols['minusSign']) . ')|(' . preg_quote($symbols['plusSign']) . '))?[0-9]+';
                        break;
                    default:
                        throw new Exception("Invalid chunk ('$intPattern') in pattern '$pattern'");
                }
            } elseif (strpos($intPattern, ',') !== false) {
                $chunks = explode(',', $intPattern);
                $maxChunkIndex = count($chunks) - 1;
                $prevChunk = null;
                for ($chunkIndex = 0; $chunkIndex <= $maxChunkIndex; ++$chunkIndex) {
                    $chunk = $chunks[$chunkIndex];
                    $nextChunk = ($chunkIndex == $maxChunkIndex) ? null : $chunks[$chunkIndex + 1];
                    switch ($chunk) {
                        case '#':
                        case '-#':
                            if ($chunk === '-#') {
                                $rx .= '(' . preg_quote($symbols['minusSign']) . ')?';
                            } else {
                                $rx .= '(' . preg_quote($symbols['plusSign']) . ')?';
                            }
                            if ($nextChunk === '##0') {
                                $rx .= '[0-9]{1,3}';
                            } elseif ($nextChunk === '##') {
                                $rx .= '[0-9]{1,2}';
                            } else {
                                throw new Exception("Invalid chunk #$chunkIndex ('$chunk') in pattern '$pattern'");
                            }
                            break;
                        case '##':
                            if ($nextChunk === '##0') {
                                $rx .= '((' . preg_quote($symbols['group']) . ')?[0-9]{2})*';
                            } else {
                                throw new Exception("Invalid chunk #$chunkIndex ('$chunk') in pattern '$pattern'");
                            }
                            break;
                        case '##0':
                            if ($prevChunk === '##') {
                                $rx .= '[0-9]';
                            } elseif (($prevChunk === '#') || ($prevChunk === '-#')) {
                                $rx .= '((' . preg_quote($symbols['group']) . ')?[0-9]{3})*';
                            } else {
                                throw new Exception("Invalid chunk #$chunkIndex ('$chunk') in pattern '$pattern'");
                            }
                            break;
                        case '#0':
                            if ($chunkIndex === 0) {
                                $rx .= '[0-9]*';
                            } else {
                                throw new Exception("Invalid chunk #$chunkIndex ('$chunk') in pattern '$pattern'");
                            }
                            break;
                    }
                    $prevChunk = $chunk;
                }
            } else {
                throw new Exception("Invalid chunk ('$intPattern') in pattern '$pattern'");
            }

            if (strlen($decimalPattern) > 0) {
                switch ($decimalPattern) {
                    case '###':
                        $rx .= '((' . preg_quote($symbols['decimal']) . ')[0-9]+)?';
                        break;
                    case '###-':
                        $rx .= '((' . preg_quote($symbols['decimal']) . ')[0-9]+)?(' . preg_quote($symbols['minusSign']) . ')';
                        break;
                    default:
                        $m = null;
                        if (preg_match('/^(0+)(-?)$/', $decimalPattern, $m)) {
                            $rx .= '(' . preg_quote($symbols['decimal']) . ')[0-9]{' . strlen($m[1]) . '}';
                            if (substr($decimalPattern, -1) === '-') {
                                $rx .= '(' . preg_quote($symbols['minusSign']) . ')';
                            }
                        } else {
                            throw new Exception("Invalid chunk ('$decimalPattern') in pattern '$pattern'");
                        }
                }
            }

            $result[$patternKey] = '/^' . $rxPre . $rx . $rxPost . '$/u';
        }

        return $result;
    }

    /**
     * @param string $destinationFile
     *
     * @throws Exception
     */
    private function copyMissingData_currency($destinationFile)
    {
        $converter = new CurrenciesLocalePunicConversion();
        $sourceData = $converter->convert($this->sourceData, 'en');
        $destinationData = include $destinationFile;
        $someChanged = false;
        foreach ($sourceData as $currency => $currencyInfo) {
            if (!array_key_exists($currency, $destinationData)) {
                $someChanged = true;
                $destinationData[$currency] = $currencyInfo;
            }
        }
        if ($someChanged) {
            $this->phpWriter->save($destinationData, $destinationFile);
        }
    }
}

abstract class PunicConversion
{
    /**
     * @var string
     */
    protected $type;

    /**
     * @var string[]
     */
    protected $roots;

    /**
     * @var string
     */
    protected $identifier;

    /**
     * @param string      $type
     * @param string[]    $roots
     * @param string|null $identifier
     */
    public function __construct($type, array $roots, $identifier = null)
    {
        $this->type = $type;
        $this->roots = $roots;
        $this->identifier = $identifier ? $identifier : end($roots);
    }

    /**
     * @return string
     */
    public function getIdentifier()
    {
        return $this->identifier;
    }

    /**
     * @param array $data
     *
     * @return $data
     */
    protected function simplify(array $data, array $roots, array $unsetByPath)
    {
        $path = '';
        foreach ($roots as $root) {
            if (!is_array($data)) {
                throw new Exception("Decoded data should be an array (path: $path)");
            }
            if (isset($unsetByPath[$path])) {
                foreach ($unsetByPath[$path] as $node) {
                    if (array_key_exists($node, $data)) {
                        unset($data[$node]);
                    }
                }
            }
            $this->checkExactKeys($data, [$root]);
            $data = $data[$root];
            $path .= "/$root";
        }
        if (!is_array($data)) {
            throw new Exception("Decoded data should be an array (path: $path)");
        }

        return $data;
    }

    /**
     * @param array|mixed $node
     * @param string[] $expectedKeys
     *
     * @throws Exception
     */
    protected function checkExactKeys($node, array $expectedKeys)
    {
        if (!is_array($node)) {
            throw new Exception("$node is not an array");
        }
        $nodeKeys = array_keys($node);
        $missingKeys = array_diff($expectedKeys, $nodeKeys);
        if (count($missingKeys) > 0) {
            throw new Exception('Missing these node keys: ' . implode(', ', $missingKeys));
        }
        $extraKeys = array_diff($nodeKeys, $expectedKeys);
        if (count($extraKeys) > 0) {
            throw new Exception('Unexpected node keys: ' . implode(', ', $extraKeys));
        }
    }

    /**
     * @param string $sourceFile
     *
     * @return array
     */
    protected function loadJson($sourceFile)
    {
        $json = @file_get_contents($sourceFile);
        if ($json === false) {
            throw new Exception("Failed to read from file $sourceFile");
        }

        $data = @json_decode($json, true);
        if ($data === null) {
            throw new Exception('Failed to decode JSON data');
        }

        return $data;
    }

    /**
     * @param string $sourceFile
     * @param array  $fallbackData
     *
     * @return array
     */
    protected function loadXml($sourceFile, $fallbackData = [])
    {
        $doc = new DOMDocument();
        $doc->load($sourceFile);

        return $this->convertDomElement($doc->documentElement, '', $fallbackData);
    }

    /**
     * @param DOMElement $element
     * @param string     $path
     * @param array      $attributes
     * @param array      $fallbackData
     *
     * @return array
     */
    protected function convertDomElement(DOMElement $element, $path, $fallbackData = null)
    {
        $paths = $this->getPaths();
        $path .= '/' . $element->tagName;

        $data = $fallbackData ? $fallbackData : [];

        foreach ($element->childNodes as $childNode) {
            switch ($childNode->nodeType) {
                case XML_ELEMENT_NODE:
                    $childPath = $path . '/' . $childNode->tagName;
                    if (isset($paths[$childPath])) {
                        $childAttributes = [];
                        $values = [];
                        foreach ($childNode->attributes as $attribute) {
                            if (in_array($attribute->name, $paths[$childPath])) {
                                $childAttributes[] = $attribute->value;
                            } else {
                                $values['_' . $attribute->name] = $attribute->value;
                            }
                        }

                        $key = implode('-', $childAttributes);
                        if ($childNode->childNodes->length === 0) {
                            $data[$childNode->tagName][$key] = $values;
                        } else {
                            $childFallbackData = isset($fallbackData[$childNode->tagName][$key]) ? $fallbackData[$childNode->tagName][$key] : [];
                            $data[$childNode->tagName][$key] = $this->convertDomElement($childNode, $path, $childFallbackData);
                        }
                    } else {
                        $childFallbackData = isset($fallbackData[$childNode->tagName]) ? $fallbackData[$childNode->tagName] : [];
                        $data[$childNode->tagName] = $this->convertDomElement($childNode, $path, $childFallbackData);
                    }
                    break;
                case XML_TEXT_NODE:
                    if ($element->childNodes->length === 1) {
                        return $childNode->wholeText;
                    }
            }
        }

        return $data;
    }

    /**
     * @param string|mixed $fmt
     *
     * @return string
     */
    protected function toPhpSprintf($fmt)
    {
        $result = $fmt;
        if (is_string($fmt)) {
            $result = str_replace('%', '%%', $result);
            $result = preg_replace_callback(
                '/\\{(\\d+)\\}/',
                function ($matches) {
                    return '%' . (1 + (int) $matches[1]) . '$s';
                },
                $fmt
            );
        }

        return $result;
    }

    /**
     * @param mixed $value
     *
     * @return bool
     */
    protected function asInt(&$value)
    {
        if (is_int($value)) {
            $result = true;
        } else {
            $result = false;
            if (is_string($value) || is_float($value)) {
                $v = @(int) $value;
                if ((string) $value === (string) $v) {
                    $value = $v;
                    $result = true;
                }
            }
        }

        return $result;
    }

    /**
     * @param mixed $value
     *
     * @return bool
     */
    protected function asNumber(&$value)
    {
        if (is_int($value) || is_float($value)) {
            $result = true;
        } else {
            $result = false;
            if (is_string($value)) {
                $v = @(int) $value;
                if ((string) $value !== (string) $v) {
                    $v = @(float) $value;
                }
                if ((string) $value === (string) $v) {
                    $value = $v;
                    $result = true;
                }
            }
        }

        return $result;
    }
}

abstract class LocalePunicConversion extends PunicConversion
{
    /**
     * @param SourceData $sourceData
     * @param string $localeID
     *
     * @return array
     */
    public function convert(SourceData $sourceData, $localeID)
    {
        $data = $this->load($sourceData, $localeID);
        $data = $this->process($data, $localeID);

        return $data;
    }

    /**
     * @param SourceData $sourceData
     * @param string     $localeID
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData, $localeID)
    {
        $file = $sourceData->getJsonDirectoryForLocale($localeID) . '/' . $this->getIdentifier() . '.json';

        if (is_file($file)) {
            return $file;
        }

        $fallbackFile = $sourceData->getJsonDirectoryForLocale('en') . '/' . $this->getIdentifier() . '.json';
        if (is_file($fallbackFile)) {
            return $fallbackFile;
        }

        throw new Exception("File not found: $file");
    }

    /**
     * @param SourceData $sourceData
     * @param string $localeID
     *
     * @return array
     */
    protected function load(SourceData $sourceData, $localeID)
    {
        $sourceFile = $this->getSourceFile($sourceData, $localeID);

        return $this->loadJson($sourceFile);
    }

    /**
     * @param string $localeID
     *
     * @return string[]
     */
    protected function getRoots($localeID)
    {
        return array_merge(
            [$this->type, str_replace('_', '-', $localeID)],
            $this->roots
        );
    }

    /**
     * @param string $localeID
     *
     * @return array
     */
    protected function getUnsetByPath($localeID)
    {
        return [
            '/' . $this->type . '/' . str_replace('_', '-', $localeID) => ['identity'],
        ];
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = $this->simplify($data, $this->getRoots($localeID), $this->getUnsetByPath($localeID));

        return $data;
    }
}

class NoopLocalePunicConversion extends LocalePunicConversion
{
    public function __construct($roots, $identitifier = null)
    {
        parent::__construct('main', $roots, $identitifier);
    }
}

class LanguagesLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['localeDisplayNames', 'languages']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $languages = parent::process($data, $localeID);

        $collator = new Collator($localeID);
        $collator->asort($languages, Collator::SORT_STRING);

        return $languages;
    }
}

class CalendarLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['dates', 'calendars', 'gregorian'], 'calendar');
    }

    /**
     * @param SourceData $sourceData
     * @param string $localeID
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData, $localeID)
    {
        return $sourceData->getJsonDirectoryForLocale($localeID) . '/ca-gregorian.json';
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        unset($data['dateTimeFormats']['appendItems']);
        foreach (array_keys($data['dateTimeFormats']) as $width) {
            $data['dateTimeFormats'][$width] = $this->toPhpSprintf($data['dateTimeFormats'][$width]);
        }
        foreach (['eraNames' => 'wide', 'eraAbbr' => 'abbreviated', 'eraNarrow' => 'narrow'] as $keyFrom => $keyTo) {
            if (array_key_exists($keyFrom, $data['eras'])) {
                $data['eras'][$keyTo] = $data['eras'][$keyFrom];
                unset($data['eras'][$keyFrom]);
            }
        }
        $data['dateTimeFormats']['intervalFormats']['intervalFormatFallback'] = $this->toPhpSprintf($data['dateTimeFormats']['intervalFormats']['intervalFormatFallback']);

        return $data;
    }
}
class TimeZoneNamesLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['dates', 'timeZoneNames']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        foreach (array_keys($data) as $dataKey) {
            switch ($dataKey) {
                case 'gmtFormat':
                case 'gmtZeroFormat':
                case 'regionFormat':
                case 'regionFormat-type-standard':
                case 'regionFormat-type-daylight':
                case 'fallbackFormat':
                    $data[$dataKey] = $this->toPhpSprintf($data[$dataKey]);
                    break;
                case 'hourFormat':
                case 'zone':
                case 'metazone':
                    break;
                default:
                    throw new Exception("Unknown data key for time zone names: $dataKey");
            }
        }

        return $data;
    }
}

class ListPatternsLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['listPatterns']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        $result = [];
        $m = null;
        foreach (array_keys($data) as $patternType) {
            if (!preg_match('/^listPattern-type-(.+)$/', $patternType, $m)) {
                throw new Exception("Invalid list patterns node '$patternType'");
            }
            $patternName = $m[1];
            $result[$patternName] = [];
            foreach ($data[$patternType] as $when => $pattern) {
                $result[$patternName][$when] = $this->toPhpSprintf($pattern);
            }
        }

        return $result;
    }
}

class UnitsLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['units']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        $m = null;
        foreach (array_keys($data) as $width) {
            switch ($width) {
                case 'long':
                case 'short':
                case 'narrow':
                case 'long':
                    foreach (array_keys($data[$width]) as $unitKey) {
                        switch ($unitKey) {
                            case 'per':
                                $this->checkExactKeys($data[$width][$unitKey], ['compoundUnitPattern']);
                                $data[$width]['_compoundPattern'] = $this->toPhpSprintf($data[$width][$unitKey]['compoundUnitPattern']);
                                unset($data[$width][$unitKey]);
                                break;
                            case 'times':
                                $this->checkExactKeys($data[$width][$unitKey], ['compoundUnitPattern']);
                                $data[$width]['_compoundPatternX'] = $this->toPhpSprintf($data[$width][$unitKey]['compoundUnitPattern']);
                                unset($data[$width][$unitKey]);
                                break;
                            case 'coordinateUnit':
                                if ($data[$width][$unitKey]['displayName']) {
                                    $displayName = $data[$width][$unitKey]['displayName'];
                                    unset($data[$width][$unitKey]['displayName']);
                                }
                                else {
                                    $displayName = null;
                                }
                                $this->checkExactKeys($data[$width][$unitKey], ['east', 'north', 'south', 'west']);
                                $data[$width]['_coordinateUnit'] = [];
                                foreach (array_keys($data[$width][$unitKey]) as $direction) {
                                    $data[$width]['_coordinateUnit'][$direction] = $this->toPhpSprintf($data[$width][$unitKey][$direction]);
                                }
                                if ($displayName !== null) {
                                    $data[$width]['_coordinateUnit']['_displayName'] = $displayName;
                                }
                                unset($data[$width][$unitKey]);
                                break;
                            default:
                                if (preg_match('/^\d\d+p\d+$/', $unitKey)) {
                                    // @todo
                                    continue 2;
                                }
                                if (preg_match('/^power\d+$/', $unitKey)) {
                                    // @todo
                                    continue 2;
                                }
                                if (!preg_match('/^(\\w+)?-(.+)$/', $unitKey, $m)) {
                                    throw new Exception("Invalid node (2) '$width/$unitKey'");
                                }
                                $unitKind = $m[1];
                                $unitName = $m[2];
                                if ($unitKind === '10p' && is_numeric($unitName)) {
                                    // @todo
                                    continue 2;
                                }
                                if (!array_key_exists($unitKind, $data[$width])) {
                                    $data[$width][$unitKind] = [];
                                }
                                if (!array_key_exists($unitName, $data[$width][$unitKind])) {
                                    $data[$width][$unitKind][$unitName] = [];
                                }
                                if (!isset($data[$width][$unitKey]['displayName'])) {
                                    throw new Exception("Missing unit name in '$width/$unitKey'");
                                }
                                if (!isset($data[$width][$unitKey]['unitPattern-count-other'])) {
                                    throw new Exception("Missing 'other' rule in '$width/$unitKey'");
                                }
                                foreach (array_keys($data[$width][$unitKey]) as $pluralRuleSrc) {
                                    switch ($pluralRuleSrc) {
                                        case 'displayName':
                                            $data[$width][$unitKind][$unitName]['_name'] = $data[$width][$unitKey][$pluralRuleSrc];
                                            break;
                                        case 'perUnitPattern':
                                            $data[$width][$unitKind][$unitName]['_per'] = $this->toPhpSprintf($data[$width][$unitKey][$pluralRuleSrc]);
                                            break;
                                        default:
                                            if (!preg_match('/^unitPattern-count-(.+)$/', $pluralRuleSrc, $m)) {
                                                throw new Exception("Invalid node (4) '$width/$unitKey/$pluralRuleSrc'");
                                            }
                                            $pluralRule = $m[1];
                                            $data[$width][$unitKind][$unitName][$pluralRule] = $this->toPhpSprintf($data[$width][$unitKey][$pluralRuleSrc]);
                                            break;
                                    }
                                }
                                unset($data[$width][$unitKey]);
                                break;
                        }
                    }
                    break;
                default:
                    if (preg_match('/^durationUnit-type-(.+)/', $width, $m)) {
                        unset($data[$width]['durationUnitPattern-alt-variant']);
                        $this->checkExactKeys($data[$width], ['durationUnitPattern']);
                        $t = $m[1];
                        if (!array_key_exists('_durationPattern', $data)) {
                            $data['_durationPattern'] = [];
                        }
                        $data['_durationPattern'][$t] = $data[$width]['durationUnitPattern'];
                        unset($data[$width]);
                    } else {
                        throw new Exception("Invalid node (6) '$width'");
                    }
                    break;
            }
        }

        return $data;
    }
}

class LocaleDisplayNamesLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['localeDisplayNames']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        if (!array_key_exists('localeDisplayPattern', $data)) {
            throw new Exception("Missing node 'localeDisplayPattern'");
        }
        foreach (array_keys($data['localeDisplayPattern']) as $k) {
            $data['localeDisplayPattern'][$k] = $this->toPhpSprintf($data['localeDisplayPattern'][$k]);
        }
        if (!array_key_exists('codePatterns', $data)) {
            throw new Exception("Missing node 'codePatterns'");
        }
        foreach (array_keys($data['codePatterns']) as $k) {
            $data['codePatterns'][$k] = $this->toPhpSprintf($data['codePatterns'][$k]);
        }

        return $data;
    }
}

class NumbersLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['numbers']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        $final = [];
        $m = null;
        foreach ($data as $key => $value) {
            if (preg_match('/^([a-z]+)-numberSystem-([a-z]+)$/i', $key, $m)) {
                $keyPrefix = $m[1];
                switch ($keyPrefix) {
                    case 'symbols':
                        $final['symbols'] = $value;
                        break;
                    case 'currencyFormats':
                    case 'percentFormats':
                        $unitPattern = null;
                        foreach ($value as $k2 => $v2) {
                            if (preg_match('/^unitPattern-(.+)$/i', $k2, $m)) {
                                if ($unitPattern === null) {
                                    $unitPattern = [];
                                }
                                $unitPattern[$m[1]] = $this->toPhpSprintf($v2);
                            } elseif (in_array($k2, ['standard', 'accounting'])) {
                                $formats = explode(';', $v2);
                                if (count($formats) === 1) {
                                    $formats[] = $final['symbols']['minusSign'] . $formats[0];
                                }
                                foreach ($formats as $i => $format) {
                                    $format = preg_replace('/[0-9@#.,E+]+/', '%1$s', str_replace('%', '%%', $format));
                                    $format = str_replace(['%%', ''], '%2$s', $format);
                                    $final[$keyPrefix][$k2][$i === 0 ? 'positive' : 'negative'] = $format;
                                }
                            } elseif ($k2 === 'currencySpacing') {
                                foreach ($v2 as $k3 => $v3) {
                                    $final[$keyPrefix]['currencySpacing'][$k3] = [
                                        'currency' => $this->toRegularExpression('currency', $k3, $v3['currencyMatch']),
                                        'surrounding' => $this->toRegularExpression('surrounding', $k3, $v3['surroundingMatch']),
                                        'insertBetween' => $v3['insertBetween'],
                                    ];
                                }
                            }
                        }
                        if ($unitPattern !== null) {
                            $final[$keyPrefix]['unitPattern'] = $unitPattern;
                        }
                        break;
                }
            } else {
                switch ($key) {
                    case 'defaultNumberingSystem':
                    case 'defaultNumberingSystem-alt-latn':
                    case 'otherNumberingSystems':
                    case 'minimalPairs':
                        break;
                    case 'minimumGroupingDigits':
                        if (!$this->asInt($value)) {
                            throw new Exception("Invalid node '$key'");
                        }
                        $final[$key] = $value;
                        break;
                    default:
                        throw new Exception("Invalid node '$key'");
                }
            }
        }
        $data = $final;

        return $data;
    }

    private function toRegularExpression($type, $position, $match)
    {
        switch ($match) {
            case '[:digit:]':
                $regexp = '\pN';
                break;
            case '[:letter:]':
                $regexp = '\pL';
                break;
            case '[:^S:]':
                $regexp = '[^\pS]';
                break;
            case '[[:^S:]&[:^Z:]]':
                $regexp = '[[^\pS]&[\S]]';
                break;
            default:
                throw new Exception("Unsupported match: $match");
        }

        if ($type === 'currency' && $position === 'beforeCurrency') {
            $regexp = '^' . $regexp;
        } else {
            $regexp .= '$';
        }

        $regexp = '/' . $regexp . '/u';

        return $regexp;
    }
}

class CurrenciesLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['numbers', 'currencies']);
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        $final = [];
        $m = null;
        foreach ($data as $currencyCode => $currencyInfo) {
            if (!preg_match('/^[A-Z]{3}$/', $currencyCode)) {
                throw new Exception("Invalid currency code: $currencyCode");
            }
            if (array_key_exists('symbol', $currencyInfo) && (strcmp($currencyInfo['symbol'], $currencyCode) === 0)) {
                unset($currencyInfo['symbol']);
            }
            foreach ($currencyInfo as $currencyInfoKey => $currencyInfoValue) {
                switch ($currencyInfoKey) {
                    case 'displayName':
                        unset($currencyInfo[$currencyInfoKey]);
                        $currencyInfo['name'] = $currencyInfoValue;
                        break;
                    case 'symbol-alt-variant':
                        if ($currencyInfoValue !== $currencyCode) {
                            $currencyInfo['symbolAlt'] = $currencyInfoValue;
                        }
                        unset($currencyInfo[$currencyInfoKey]);
                        break;
                    case 'symbol-alt-narrow':
                        if ($currencyInfoValue !== $currencyCode) {
                            $currencyInfo['symbolNarrow'] = $currencyInfoValue;
                        }
                        unset($currencyInfo[$currencyInfoKey]);
                        break;
                    default:
                        if (preg_match('/^displayName-count-(.+)$/', $currencyInfoKey, $m)) {
                            if (!array_key_exists('pluralName', $currencyInfo)) {
                                $currencyInfo['pluralName'] = [];
                            }
                            $currencyInfo['pluralName'][$m[1]] = $currencyInfoValue;
                            unset($currencyInfo[$currencyInfoKey]);
                        }
                        break;
                }
            }
            if (array_key_exists('pluralName', $currencyInfo)) {
                if (!array_key_exists('other', $currencyInfo['pluralName'])) {
                    throw new Exception("Missing 'other' plural rule for currency $currencyCode");
                }
                if (!array_key_exists('name', $currencyInfo)) {
                    if (array_key_exists('one', $currencyInfo['pluralName'])) {
                        $currencyInfo['name'] = $currencyInfo['pluralName']['one'];
                    } else {
                        $currencyInfo['name'] = $currencyInfo['pluralName']['other'];
                    }
                }
            }
            if (!array_key_exists('name', $currencyInfo)) {
                $currencyInfo['name'] = $currencyCode;
            }
            if (array_key_exists('pluralName', $currencyInfo)) {
                if ((count($currencyInfo['pluralName']) === 1) && (strcmp($currencyInfo['pluralName']['other'], $currencyInfo['name']) === 0)) {
                    unset($currencyInfo['pluralName']);
                }
            }
            $final[$currencyCode] = $currencyInfo;
        }
        $data = $final;

        $collator = new Collator($localeID);
        uasort($data, function ($a, $b) use ($collator) {
            $ab = [$a['name'], $b['name']];
            $collator->sort($ab);
            $i = array_search($a['name'], $ab, true);
            if ($i === 1) {
                return 1;
            }
            $i = array_search($b['name'], $ab, true);
            if ($i === 1) {
                return -1;
            }

            return 0;
        });

        return $data;
    }
}

class SubdivisionsLocalePunicConversion extends LocalePunicConversion
{
    /**
     * @var string
     */
    private $localeDisplayNamesFile;

    public function __construct($localeDisplayNamesFile)
    {
        parent::__construct('subdivisions', ['localeDisplayNames', 'subdivisions', 'subdivision'], 'subdivisions');

        $this->localeDisplayNamesFile = $localeDisplayNamesFile;
    }

    /**
     * @param SourceData $sourceData
     * @param string     $localeID
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData, $localeID)
    {
        return $sourceData->getRepositoryDirectory() . '/common/subdivisions/' . $localeID . '.xml';
    }

    /**
     * @return array
     */
    protected function getPaths()
    {
        return ['/ldml/localeDisplayNames/subdivisions/subdivision' => ['type']];
    }

    /**
     * @param SourceData $sourceData
     * @param string     $localeID
     *
     * @return array
     */
    protected function load(SourceData $sourceData, $localeID)
    {
        $locale = LocaleIdentifier::fromString($localeID);
        $localeIDs = array_merge([$localeID], $locale->getParentLocaleIdentifiers(), ['en']);

        // As of CLDR 36, England, Scotland and Wales are not stored in the subdivisions/*.xml.
        $localeDisplayNames = require $this->localeDisplayNamesFile;

        $key = str_replace('_', '-', $localeID);
        $data = [
            $this->type => [
                $key => [
                    'localeDisplayNames' => [
                        'subdivisions' => [
                            'subdivision' => $localeDisplayNames['subdivisions'] ?? [],
                        ],
                    ],
                ],
            ],
        ];

        foreach (array_reverse($localeIDs) as $localeID) {
            $sourceFile = $this->getSourceFile($sourceData, $localeID);
            if (is_file($sourceFile)) {
                $data[$this->type][$key] = $this->loadXml($sourceFile, $data[$this->type][$key]);
            }
        }

        uksort($data[$this->type][$key]['localeDisplayNames']['subdivisions']['subdivision'], 'strcasecmp');

        return $data;
    }
}

class RbnfLocalePunicConversion extends LocalePunicConversion
{
    public function __construct()
    {
        parent::__construct('rbnf', ['rbnf', 'rbnf'], 'rbnf');
    }

    /**
     * @param SourceData $sourceData
     * @param string $localeID
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData, $localeID)
    {
        $base = $sourceData->getJsonDirectoryForGeneric('rbnf') . '/';

        return $base . (version_compare($sourceData->getOptions()->getCLDRVersion(), '38') >= 0 ? "{$localeID}/{$localeID}.json" : "{$localeID}.json");
    }

    /**
     * @param SourceData $sourceData
     * @param string     $localeID
     *
     * @return array
     */
    protected function load(SourceData $sourceData, $localeID)
    {
        $locale = LocaleIdentifier::fromString($localeID);
        $localeIDs = array_merge([$localeID], $locale->getParentLocaleIdentifiers());
        $data = [];
        foreach ($localeIDs as $localeID) {
            $file = $this->getSourceFile($sourceData, $localeID);
            if (file_exists($file)) {
                $parent = parent::load($sourceData, $localeID);
                foreach ($parent['rbnf']['rbnf'] as $group => $rulesetGrouping) {
                    if (!isset($data['rbnf']['rbnf'][$group])) {
                        $data['rbnf']['rbnf'][$group] = [];
                    }
                    $data['rbnf']['rbnf'][$group] += $rulesetGrouping;
                }
            }
        }

        return $data;
    }

    /**
     * @param string $localeID
     *
     * @return string[]
     */
    protected function getRoots($localeID)
    {
        return $this->roots;
    }

    /**
     * @param string $localeID
     *
     * @return array
     */
    protected function getUnsetByPath($localeID)
    {
        return [
            '/rbnf' => ['identity'],
        ];
    }

    /**
     * @param array $data
     * @param string $localeID
     *
     * @return array
     */
    protected function process(array $data, $localeID)
    {
        $data = parent::process($data, $localeID);
        $rulesets = [];
        foreach ($data as $group => $rulesetGrouping) {
            if ($group === 'NumberingSystemRules' && $localeID !== 'root') {
                continue;
            }
            foreach ($rulesetGrouping as $type => $ruleset) {
                $type = substr($type, 1);
                foreach ($ruleset as $descriptor => $rule) {
                    if ($rule[0] === "'") {
                        $rule = substr($rule, 1);
                    }
                    $rule = rtrim($rule, ';');
                    $parts = explode('/', $descriptor);
                    $base = $parts[0];
                    if (is_numeric($base)) {
                        $rulesets[$type]['integer'][$base]['rule'] = $rule;
                        if (count($parts) > 1) {
                            $rulesets[$type]['integer'][$base]['radix'] = (int) $parts[1];
                        }
                    } else {
                        $rulesets[$type][$base]['rule'] = $rule;
                    }
                }
            }
        }
        $data = $rulesets;

        return $data;
    }
}

abstract class SupplementalPunicConversion extends PunicConversion
{
    /**
     * @param SourceData $sourceData
     *
     * @return array
     */
    public function convert(SourceData $sourceData)
    {
        $data = $this->load($sourceData);
        $data = $this->process($data);

        return $data;
    }

    /**
     * @param SourceData $sourceData
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData)
    {
        $supplementalDir = $sourceData->getJsonDirectoryForGeneric('supplemental');
        $identifier = $this->getIdentifier();
        if (version_compare($sourceData->getOptions()->getCLDRVersion(), '38') >= 0) {
            switch ($identifier) {
                case 'codeMappings':
                case 'currencyData':
                case 'measurementData':
                case 'parentLocales':
                case 'territoryContainment':
                case 'territoryInfo':
                case 'timeData':
                case 'weekData':
                    return "{$supplementalDir}/supplementalData/{$identifier}.json";
                case 'dayPeriods':
                    return "{$supplementalDir}/dayPeriods/{$identifier}.json";
                case 'likelySubtags':
                    return "{$supplementalDir}/likelySubtags/{$identifier}.json";
                case 'primaryZones':
                case 'metaZones':
                    return "{$supplementalDir}/metaZones/{$identifier}.json";
                case 'ordinals':
                    return "{$supplementalDir}/ordinals/{$identifier}.json";
                case 'plurals':
                    return "{$supplementalDir}/plurals/{$identifier}.json";
            }
        }

        return "{$supplementalDir}/{$identifier}.json";
    }

    /**
     * @param string $json
     *
     * @return array
     */
    protected function load(SourceData $sourceData)
    {
        $sourceFile = $this->getSourceFile($sourceData);

        return $this->loadJson($sourceFile);
    }

    /**
     * @return string[]
     */
    protected function getRoots()
    {
        return $this->roots;
    }

    /**
     * @return array
     */
    protected function getUnsetByPath()
    {
        return [
            '/supplemental' => ['version', 'generation'],
        ];
    }

    /**
     * @param array $data
     */
    protected function process($data)
    {
        $data = $this->simplify($data, $this->getRoots(), $this->getUnsetByPath());

        return $data;
    }
}

class NoopSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct(array $roots, $identifier = null)
    {
        parent::__construct('supplemental', $roots, $identifier);
    }
}

class TelephoneCodeDataSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'telephoneCodeData']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        foreach (array_keys($data) as $k) {
            if (!preg_match('/^([A-Z]{2}|[0-9]{3})$/', $k)) {
                throw new Exception("Invalid territory ID: $k");
            }
            $d = $data[$k];
            if ((!is_array($d)) || empty($d)) {
                throw new Exception("Expecting non empty array for $k, found " . gettype($d));
            }
            $data[$k] = [];
            $n = count($d);
            for ($i = 0; $i < $n; ++$i) {
                if (!isset($d[$i])) {
                    throw new Exception("Invalid array for $k");
                }
                if ((!is_array($d[$i])) || (count($d[$i]) !== 1) || (!array_key_exists('telephoneCountryCode', $d[$i])) || (!is_string($d[$i]['telephoneCountryCode'])) || (!strlen($d[$i]['telephoneCountryCode']))) {
                    throw new Exception("Invalid telephoneCountryCode for $k");
                }
                $data[$k][] = $d[$i]['telephoneCountryCode'];
            }
            sort($data[$k]);
        }

        return $this->sortData($data);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function sortData(array $data)
    {
        foreach (array_keys($data) as $k) {
            sort($data[$k]);
        }
        uksort($data, function ($a, $b) {
            if (is_numeric($a)) {
                if (is_numeric($b)) {
                    return (int) $a - (int) $b;
                }

                return -1;
            }
            if (is_numeric($b)) {
                return 1;
            }

            return strcasecmp($a, $b);
        });

        return $data;
    }
}

class TelephoneCodeDataLibphonenumberPunicConversion extends TelephoneCodeDataSupplementalPunicConversion
{
    protected $territoryMap = [
        'TA' => 'SH', // Saint Helena, Ascension and Tristan da Cunha
    ];

    /**
     * {@inheritdoc}
     *
     * @see SupplementalPunicConversion::load()
     */
    protected function load(SourceData $sourceData)
    {
        $localFile = "{$sourceData->getOptions()->getTemporaryDirectory()}/PhoneNumberMetadata-{$sourceData->getOptions()->getLibphonenumberVersion()}.xml";
        $url = "https://github.com/googlei18n/libphonenumber/raw/{$sourceData->getOptions()->getLibphonenumberVersion()}/resources/PhoneNumberMetadata.xml";
        if (is_file($localFile)) {
            $xmlData = @file_get_contents($localFile);
            if (!$xmlData) {
                @unlink($localFile);
            }
        } else {
            $xmlData = false;
        }
        if (!$xmlData) {
            $xmlData = @file_get_contents($url);
            if (!$xmlData) {
                throw new Exception("Failed to download libphonenumber data from {$url}");
            }
        }
        $old = libxml_use_internal_errors(true);
        libxml_clear_errors();
        $xml = simplexml_load_string($xmlData);
        if ($xml === false) {
            $msg = "Failed to parse XML from {$url}:";
            foreach (libxml_get_errors() as $error) {
                $msg .= "\n - line {$error->line}: $error->message";
            }
            libxml_clear_errors();
            libxml_use_internal_errors($old);
            throw new Exception($msg);
        }
        libxml_use_internal_errors($old);
        if (!is_file($localFile)) {
            @file_put_contents($localFile, $xmlData);
        }

        return $xml;
    }

    /**
     * {@inheritdoc}
     *
     * @see SupplementalPunicConversion::convert()
     */
    protected function process($data)
    {
        /* @var SimpleXMLElement $data */
        $telephoneCodeData = [];
        $territories = $data->xpath('/phoneNumberMetadata/territories/territory[@id][@countryCode]');
        foreach ($territories as $territory) {
            $territoryID = (string) $territory['id'];
            if (isset($this->territoryMap[$territoryID])) {
                $territoryID = $this->territoryMap[$territoryID];
            }
            if (!isset($telephoneCodeData[$territoryID])) {
                $telephoneCodeData[$territoryID] = [];
            }
            $phonePrefix = (string) $territory['countryCode'];
            if (!in_array($phonePrefix, $telephoneCodeData[$territoryID], true)) {
                $telephoneCodeData[$territoryID][] = $phonePrefix;
            }
        }

        return $this->sortData($telephoneCodeData);
    }
}

class TerritoryInfoSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'territoryInfo']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        //http://www.unicode.org/reports/tr35/tr35-info.html#Supplemental_Territory_Information
        unset($data['ZZ']);
        foreach ($data as $territoryID => $territoryInfoList) {
            $finalTerritoryData = [];
            foreach ($territoryInfoList as $territoryInfoID => $territoryInfoData) {
                switch ($territoryInfoID) {
                    case '_gdp': // Gross domestic product
                        if (!$this->asNumber($territoryInfoData)) {
                            throw new Exception("Unable to parse $territoryInfoData as a number ($territoryInfoID)");
                        }
                        $finalTerritoryData['gdp'] = $territoryInfoData;
                        break;
                    case '_literacyPercent':
                        if (!$this->asNumber($territoryInfoData)) {
                            throw new Exception("Unable to parse $territoryInfoData as a number ($territoryInfoID)");
                        }
                        $finalTerritoryData['literacy'] = $territoryInfoData;
                        break;
                    case '_population':
                        if (!$this->asNumber($territoryInfoData)) {
                            throw new Exception("Unable to parse $territoryInfoData as a number ($territoryInfoID)");
                        }
                        $finalTerritoryData['population'] = $territoryInfoData;
                        break;
                    case 'languagePopulation':
                        if (!is_array($territoryInfoData)) {
                            throw new Exception("Invalid node: $territoryInfoID is not an array");
                        }
                        $finalTerritoryData['languages'] = [];
                        foreach ($territoryInfoData as $languageID => $languageInfoList) {
                            if (!is_array($languageInfoList)) {
                                throw new Exception("Invalid node: $territoryInfoID/$languageID is not an array");
                            }
                            $finalTerritoryData['languages'][$languageID] = [];
                            foreach ($languageInfoList as $languageInfoID => $languageInfoData) {
                                switch ($languageInfoID) {
                                    case '_officialStatus':
                                        switch ($languageInfoData) {
                                            case 'official':
                                                $v = 'o';
                                                break;
                                            case 'official_regional':
                                                $v = 'r';
                                                break;
                                            case 'de_facto_official':
                                                $v = 'f';
                                                break;
                                            case 'official_minority':
                                                $v = 'm';
                                                break;
                                            default:
                                                throw new Exception("Unknown language status: $languageInfoData");
                                        }
                                        $finalTerritoryData['languages'][$languageID]['status'] = $v;
                                        break;
                                    case '_populationPercent':
                                        if (!$this->asNumber($languageInfoData)) {
                                            throw new Exception("Unable to parse $languageInfoData as a number ($territoryInfoID)");
                                        }
                                        $finalTerritoryData['languages'][$languageID]['population'] = $languageInfoData;
                                        break;
                                    case '_writingPercent':
                                        if (!$this->asNumber($languageInfoData)) {
                                            throw new Exception("Unable to parse $languageInfoData as a number ($territoryInfoID)");
                                        }
                                        $finalTerritoryData['languages'][$languageID]['writing'] = $languageInfoData;
                                        break;
                                    case '_literacyPercent':
                                        if (!$this->asNumber($languageInfoData)) {
                                            throw new Exception("Unable to parse $languageInfoData as a number ($territoryInfoID)");
                                        }
                                        $finalTerritoryData['languages'][$languageID]['literacy'] = $languageInfoData;
                                        break;
                                    default:
                                        throw new Exception("Unknown node: $territoryInfoID/$languageID/$languageInfoID");
                                }
                            }
                            if (!array_key_exists('population', $finalTerritoryData['languages'][$languageID])) {
                                throw new Exception("Missing _populationPercent node in for $territoryID/$territoryInfoID/$languageID");
                            }
                        }
                        if (empty($finalTerritoryData['languages'])) {
                            throw new Exception("No languages for $territoryID");
                        }
                        break;
                    default:
                        throw new Exception("Unknown node: $territoryInfoID");
                }
            }
            if (!array_key_exists('gdp', $finalTerritoryData)) {
                throw new Exception("Missing _gdp node in for $territoryID");
            }
            if (!array_key_exists('literacy', $finalTerritoryData)) {
                throw new Exception("Missing _literacyPercent node in for $territoryID");
            }
            if (!array_key_exists('population', $finalTerritoryData)) {
                throw new Exception("Missing _population node in for $territoryID");
            }
            if (!array_key_exists('languages', $finalTerritoryData)) {
                throw new Exception("Missing languagePopulation node in for $territoryID");
            }
            $data[$territoryID] = $finalTerritoryData;
        }

        return $data;
    }
}

class TimeDataSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'timeData']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        foreach (array_keys($data) as $key) {
            $data[$key]['preferred'] = $data[$key]['_preferred'];
            unset($data[$key]['_preferred']);

            $data[$key]['allowed'] = explode(' ', $data[$key]['_allowed']);
            unset($data[$key]['_allowed']);
        }

        return $data;
    }
}

class DayPeriodsSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'dayPeriodRuleSet'], 'dayPeriods');
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        foreach (array_keys($data) as $l) {
            unset($data[$l]['am']);
            unset($data[$l]['pm']);
            unset($data[$l]['noon']);
            unset($data[$l]['midnight']);

            foreach (array_keys($data[$l]) as $period) {
                if (isset($data[$l]['at'])) {
                    unset($data[$l]);
                } else {
                    $data[$l][$period]['from'] = $data[$l][$period]['_from'];
                    $data[$l][$period]['before'] = $data[$l][$period]['_before'];
                    unset($data[$l][$period]['_from']);
                    unset($data[$l][$period]['_before']);
                }
            }

            uasort($data[$l], function ($rule1, $rule2) {
                return strcmp($rule1['before'], $rule2['before']);
            });
        }

        return $data;
    }
}

class WeekDataSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'weekData']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        foreach (array_keys($data['minDays']) as $key) {
            $value = $data['minDays'][$key];
            if (!preg_match('/^[0-9]+$/', $value)) {
                throw new Exception("Bad number: $value");
            }
            $data['minDays'][$key] = (int) $value;
        }
        $dict = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
        foreach (array_keys($data['firstDay']) as $key) {
            $val = array_search($data['firstDay'][$key], $dict, true);
            if ($val === false) {
                throw new Exception("Unknown weekday name: {$data['firstDay'][$key]}");
            }
            $data['firstDay'][$key] = $val;
        }
        unset($data['firstDay-alt-variant']);
        unset($data['weekendStart']);
        unset($data['weekendEnd']);

        return $data;
    }
}

class TerritoryContainmentSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'territoryContainment']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        foreach (array_keys($data) as $key) {
            if (array_key_exists('_grouping', $data[$key])) {
                unset($data[$key]['_grouping']);
            }
            if (array_key_exists('_contains', $data[$key])) {
                $data[$key]['contains'] = $data[$key]['_contains'];
                unset($data[$key]['_contains']);
            }
            if (strpos($key, '-status-') !== false) {
                unset($data[$key]);
            }
        }

        return $data;
    }
}

class MetaZonesSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'metaZones']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        $this->checkExactKeys($data['metazoneInfo'], ['timezone']);
        $data['metazoneInfo'] = $data['metazoneInfo']['timezone'];
        foreach ($data['metazoneInfo'] as $id0 => $info0) {
            foreach ($info0 as $id1 => $info1) {
                if (is_int($id1)) {
                    $info1 = $this->fixMetazoneInfo($info1);
                } else {
                    foreach ($info1 as $id2 => $info2) {
                        if (is_int($id2)) {
                            $info2 = $this->fixMetazoneInfo($info2);
                        } else {
                            foreach ($info2 as $id3 => $info3) {
                                if (is_int($id3)) {
                                    $info3 = $this->fixMetazoneInfo($info3);
                                } else {
                                    throw new Exception('Invalid metazoneInfo node');
                                }
                                $info2[$id3] = $info3;
                            }
                        }
                        $info1[$id2] = $info2;
                    }
                }
                $info0[$id1] = $info1;
            }
            $data['metazoneInfo'][$id0] = $info0;
        }
        $metazones = [];
        if ((!array_key_exists('metazones', $data)) && is_array($data['metazones']) && (count($data['metazones']) > 0)) {
            throw new Exception('metazones node not found/invalid');
        }
        foreach ($data['metazones'] as $mz) {
            $this->checkExactKeys($mz, ['mapZone']);
            $mz = $mz['mapZone'];
            foreach (array_keys($mz) as $i) {
                switch ($i) {
                    case '_other':
                    case '_territory':
                    case '_type':
                        $mz[substr($i, 1)] = $mz[$i];
                        unset($mz[$i]);
                        break;
                    default:
                        throw new Exception('Invalid mapZone node key: ' . $i);
                }
            }
            $metazones[] = $mz;
        }
        $data['metazones'] = $metazones;

        return $data;
    }

    /**
     * @param array|mixed $a
     *
     * @throws Exception
     *
     * @return array
     */
    private function fixMetazoneInfo($a)
    {
        $this->checkExactKeys($a, ['usesMetazone']);
        $a = $a['usesMetazone'];
        foreach (array_keys($a) as $key) {
            switch ($key) {
                case '_mzone':
                case '_from':
                case '_to':
                    $a[substr($key, 1)] = $a[$key];
                    unset($a[$key]);
                    break;
                default:
                    throw new Exception('Invalid metazoneInfo node');
            }
        }

        return $a;
    }
}

class PluralsSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct($type, $identifier)
    {
        parent::__construct('supplemental', ['supplemental', 'plurals-type-' . $type], $identifier);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    private function realProcess(array $data)
    {
        $data = parent::process($data);
        $testData = [];
        $m = null;
        foreach ($data as $l => $lData) {
            $testData[$l] = [];
            $keys = array_keys($lData);
            foreach ($keys as $key) {
                if (!preg_match('/^pluralRule-count-(.+)$/', $key, $m)) {
                    throw new Exception("Invalid node '$key'");
                }
                $rule = $m[1];
                $testData[$l][$rule] = [];
                $vOriginal = $lData[$key];
                $examples = explode('@', $vOriginal);
                $v = trim(array_shift($examples));
                foreach ($examples as $example) {
                    list($exampleNumberType, $exampleValues) = explode(' ', $example, 2);
                    switch ($exampleNumberType) {
                        case 'integer':
                        case 'decimal':
                            $exampleValues = preg_replace('/, $/', '', $exampleValues);
                            $exampleValuesParsed = [];
                            foreach (explode(', ', trim($exampleValues)) as $ev) {
                                if (preg_match('/^[+\-]?\d+$/', $ev)) {
                                    $exampleValuesParsed[] = $ev;
                                    $exampleValuesParsed[] = (int) $ev;
                                } elseif (preg_match('/^[+\-]?\d+\.\d+$/', $ev)) {
                                    $exampleValuesParsed[] = $ev;
                                } elseif (preg_match('/^([+\-]?\d+)~([+\-]?\d+)$/', $ev, $m)) {
                                    $exampleValuesParsed[] = $m[1];
                                    $exampleValuesParsed[] = (int) $m[1];
                                    $exampleValuesParsed[] = $m[2];
                                    $exampleValuesParsed[] = (int) $m[2];
                                } elseif (preg_match('/^([+\-]?\d+(\.\d+)?)~([+\-]?\d+(\.\d+)?)$/', $ev, $m)) {
                                    $exampleValuesParsed[] = $m[1];
                                    $exampleValuesParsed[] = $m[3];
                                } elseif (preg_match('/^(\d+(?:\.\d+)?)e(\d+)$/', $ev, $m)) {
                                    $exampleValuesParsed[] = $ev;
                                } elseif ($ev !== '') {
                                    throw new Exception("Invalid node '$key': $vOriginal");
                                }
                            }
                            $testData[$l][$rule] = $exampleValuesParsed;
                            break;
                        default:
                            throw new Exception("Invalid node '$key': $vOriginal");
                    }
                }
                if ($rule === 'other') {
                    if (strlen($v) > 0) {
                        throw new Exception("Invalid node '$key': $vOriginal");
                    }
                } else {
                    $v = preg_replace('/ ?!= ?/', ' != ', $v);
                    $v = preg_replace('/([^!]) ?= ?/', '\1 == ', $v);
                    $v = preg_replace('/ ?% ?/', ' % ', $v);
                    $map = [' == ' => 'true', ' != ' => 'false'];
                    $startPattern = '^| and | or ';
                    $leftPattern = '[nivwftce](?: % \d+)?';
                    $operatorPattern = ' == | != ';
                    $rightPattern = '\d+(?:(?:\.\.|,)\d+)+';
                    while (preg_match("/(?:$startPattern)(($leftPattern)($operatorPattern)($rightPattern))/", $v, $m)) {
                        $found = $m[1];
                        $left = $m[2]; // eg 'n % 10'
                        $operator = $m[3]; // eg '=='
                        $right =$m[4];
                        $ranges = explode(',', $right);
                        foreach (array_keys($ranges) as $j) {
                            if (preg_match('/^(\\d+)\\.\\.(\\d+)$/', $ranges[$j], $m)) {
                                $ranges[$j] = "array({$m[1]}, {$m[2]})";
                            }
                        }
                        $replace = "static::inRange($left, {$map[$operator]}, " . implode(', ', $ranges) . ')';
                        $v = str_replace($found, $replace, $v);
                    }
                    if (strpos($v, '..') !== false) {
                        throw new Exception("Invalid node '$key': $vOriginal (not converted part: \"{$v}\"");
                    }
                    foreach ([
                        'n' => '%1$s', // absolute value of the source number (integer and decimals).
                        'i' => '%2$s', // integer digits of n
                        'v' => '%3$s', // number of visible fraction digits in n, with trailing zeros.
                        'w' => '%4$s', // number of visible fraction digits in n, without trailing zeros.
                        'f' => '%5$s', // visible fractional digits in n, with trailing zeros.
                        't' => '%6$s', // visible fractional digits in n, without trailing zeros.
                        'c' => '%7$s', // compact decimal exponent value: exponent of the power of 10 used in compact decimal formatting.
                        'e' => '%7$s', // currently, synonym for c. however, may be redefined in the future.
                    ] as $from => $to) {
                        $v = preg_replace('/^' . $from . ' /', "$to ", $v);
                        $v = preg_replace("/^$from /", "$to ", $v);
                        $v = str_replace(" $from ", " $to ", $v);
                        $v = str_replace("($from, ", "($to, ", $v);
                        $v = str_replace("($from ", "($to ", $v);
                        $v = str_replace(" $from,", " $to,", $v);
                    }
                    $v = str_replace(' % ', ' %% ', $v);
                    $lData[$rule] = $v;
                }
                unset($lData[$key]);
            }
            $data[$l] = $lData;
        }

        return [$data, $testData];
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $dt = $this->realProcess($data);

        return $dt[0];
    }

    /**
     * @param SourceData $sourceData
     *
     * @return array
     */
    public function convertTestData(SourceData $sourceData)
    {
        $data = $this->load($sourceData);
        $dt = $this->realProcess($data);

        return $dt[1];
    }
}

class MeasurementDataSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'measurementData']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        if (!(array_key_exists('measurementSystem', $data) && is_array($data['measurementSystem']))) {
            throw new Exception('Missing/invalid key: measurementSystem');
        }
        if (!(array_key_exists('paperSize', $data) && is_array($data['paperSize']))) {
            throw new Exception('Missing/invalid key: paperSize');
        }

        return $data;
    }
}

class CurrencyDataSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('main', ['supplemental', 'currencyData']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        $keys = ['fractions', 'region'];
        if ((count($data) !== count($keys)) || (count(array_diff($keys, array_keys($data))) !== 0)) {
            throw new Exception('Unexpected keys in currencyData.json');
        }
        $final = [];
        if (!array_key_exists('DEFAULT', $data['fractions'])) {
            throw new Exception('Missing DEFAULT in currencyData.json');
        }
        $parseFraction = function ($info, $defaultValues) {
            $result = [];
            foreach (['_digits' => 'digits', '_rounding' => 'rounding', '_cashDigits' => 'cashDigits', '_cashRounding' => 'cashRounding'] as $keyFrom => $keyTo) {
                if (array_key_exists($keyTo, $info)) {
                    throw new Exception("$keyTo already exist in array");
                }
                if (array_key_exists($keyFrom, $info)) {
                    $v = $info[$keyFrom];
                    unset($info[$keyFrom]);
                    switch (gettype($v)) {
                        case 'integer':
                            break;
                        case 'string':
                            if (!preg_match('/^[0-9]+$/', $v)) {
                                throw new Exception("$keyFrom is invalid");
                            }
                            $v = (int) $v;
                            break;
                        default:
                            throw new Exception("$keyFrom is invalid");
                    }
                    switch ($keyTo) {
                        case 'rounding':
                        case 'cashRounding':
                            if ($v === 0) {
                                $v = 1;
                            }
                            break;
                    }
                    $result[$keyTo] = $v;
                }
            }
            if (!empty($info)) {
                throw new Exception('Unexpected data in currency franction');
            }
            if (array_key_exists('cashDigits', $result) && array_key_exists('digits', $result) && ($result['cashDigits'] === $result['digits'])) {
                unset($result['cashDigits']);
            }
            if (array_key_exists('cashRounding', $result) && array_key_exists('rounding', $result) && ($result['cashRounding'] === $result['rounding'])) {
                unset($result['cashRounding']);
            }
            if ($defaultValues === true) {
                if (!array_key_exists('digits', $result)) {
                    throw new Exception('Missing default rounding');
                }
                if (!array_key_exists('digits', $result)) {
                    throw new Exception('Missing default rounding');
                }
            } else {
                if (array_key_exists('digits', $result) && ($result['digits'] === $defaultValues['digits'])) {
                    unset($result['digits']);
                }
                if (array_key_exists('rounding', $result) && ($result['rounding'] === $defaultValues['rounding'])) {
                    unset($result['rounding']);
                }
            }

            return $result;
        };
        $final['fractionsDefault'] = $parseFraction($data['fractions']['DEFAULT'], true);
        unset($data['fractions']['DEFAULT']);
        $final['fractions'] = [];
        foreach ($data['fractions'] as $currencyCode => $currencyInfo) {
            $currencyInfo = $parseFraction($currencyInfo, $final['fractionsDefault']);
            if (!empty($currencyInfo)) {
                $final['fractions'][$currencyCode] = $currencyInfo;
            }
        }
        $parseRegion = function ($currencyInfo) {
            $result = [];
            if (array_key_exists('_tender', $currencyInfo)) {
                if ($currencyInfo['_tender'] !== 'false') {
                    throw new Exception('Invalid _tender value');
                }
                unset($currencyInfo['_tender']);
                $result['notTender'] = true;
            }
            foreach (['_from' => 'from', '_to' => 'to'] as $keyFrom => $keyTo) {
                if (array_key_exists($keyFrom, $currencyInfo)) {
                    $v = $currencyInfo[$keyFrom];
                    unset($currencyInfo[$keyFrom]);
                    if (!(is_string($v) && preg_match('/^[0-9]{4}-[0-1][0-9]-[0-3][0-9]$/', $v))) {
                        throw new Exception("Invalid $keyFrom value");
                    }
                    $result[$keyTo] = $v;
                }
            }
            if (!empty($currencyInfo)) {
                throw new Exception('Unknown currency info keys found: ' . implode(', ', array_keys($currencyInfo)));
            }
            if (empty($result)) {
                throw new Exception('Empty currency info');
            }

            return $result;
        };
        $final['regions'] = [];
        foreach ($data['region'] as $territoryCode => $territoryInfos) {
            if (is_int($territoryCode)) {
                $territoryCode = substr('00' . $territoryCode, -3);
            }
            $final['regions'][$territoryCode] = [];
            foreach ($territoryInfos as $territoryInfo) {
                foreach ($territoryInfo as $currencyCode => $currencyInfo) {
                    $final['regions'][$territoryCode][] = array_merge(['currency' => $currencyCode], $parseRegion($currencyInfo));
                }
            }
            usort($final['regions'][$territoryCode], function ($a, $b) {
                if (array_key_exists('notTender', $a) && $a['notTender']) {
                    if (!array_key_exists('notTender', $b)) {
                        return 1;
                    }
                } elseif (array_key_exists('notTender', $b) && $b['notTender']) {
                    return -1;
                }
                if (array_key_exists('to', $a)) {
                    if (array_key_exists('to', $b)) {
                        if ($a['to'] !== $b['to']) {
                            return strcmp($b['to'], $a['to']);
                        }
                    } else {
                        return 1;
                    }
                } elseif (array_key_exists('to', $b)) {
                    return -1;
                }

                return 0;
            });
        }
        $data = $final;

        return $data;
    }
}

class CodeMappingsSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'codeMappings']);
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $mappings = parent::process($data);

        $data = [];
        foreach ($mappings as $key => $mapping) {
            if (strlen($key) === 2) {
                $type = 'territories';
            } else {
                $type = 'currencies';
            }
            foreach ($mapping as $name => $value) {
                if ($name[0] === '_') {
                    if ($name === '_internet') {
                        $value = explode(' ', $value);
                    }
                    if ($type === 'currencies' && $name === '_numeric') {
                        $value = (int) $value;
                    }
                    $data[$type][$key][substr($name, 1)] = $value;
                }
            }
        }

        return $data;
    }
}

class SubdivisionsSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'subdivisionContainment', 'subgroup'], 'subdivisionContainment');
    }

    /**
     * @param SourceData $sourceData
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData)
    {
        return $sourceData->getRepositoryDirectory() . '/common/supplemental/subdivisions.xml';
    }

    /**
     * @return array
     */
    protected function getPaths()
    {
        return ['/supplementalData/subdivisionContainment/subgroup' => ['type']];
    }

    /**
     * @param SourceData $sourceData
     *
     * @return array
     */
    protected function load(SourceData $sourceData)
    {
        $sourceFile = $this->getSourceFile($sourceData);

        $data = [
            'supplemental' => $this->loadXml($sourceFile),
        ];

        return $data;
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $data = parent::process($data);
        foreach (array_keys($data) as $key) {
            $data[$key]['contains'] = explode(' ', $data[$key]['_contains']);
            unset($data[$key]['_contains']);
        }

        return $data;
    }
}

class TimeZoneSupplementalPunicConversion extends SupplementalPunicConversion
{
    public function __construct()
    {
        parent::__construct('supplemental', ['supplemental', 'keyword', 'key', 'type'], 'timeZones');
    }

    /**
     * @param SourceData $sourceData
     *
     * @return string
     */
    protected function getSourceFile(SourceData $sourceData)
    {
        return $sourceData->getRepositoryDirectory() . '/common/bcp47/timezone.xml';
    }

    /**
     * @return array
     */
    protected function getPaths()
    {
        return ['/ldmlBCP47/keyword/key/type' => ['alias']];
    }

    /**
     * @param SourceData $sourceData
     *
     * @return array
     */
    protected function load(SourceData $sourceData)
    {
        $sourceFile = $this->getSourceFile($sourceData);

        $data = [
            'supplemental' => $this->loadXml($sourceFile),
        ];

        return $data;
    }

    /**
     * @param array $data
     *
     * @return array
     */
    protected function process($data)
    {
        $zones = parent::process($data);
        $data = [];
        foreach (array_keys($zones) as $zone) {
            $aliases = explode(' ', $zone);
            if (count($aliases) > 1) {
                $zoneID = array_shift($aliases);
                foreach ($aliases as $alias) {
                    $data['aliases'][$alias] = $zoneID;
                }
            }
        }

        return $data;
    }
}

class StateFile
{
    /**
     * @var string
     */
    private $path;

    /**
     * @var resource|null
     */
    private $handle = null;

    /**
     * @var bool
     */
    private $locked = false;

    /**
     * @var bool
     */
    private $delete = false;

    /**
     * @param string $path
     */
    private function __construct($path)
    {
        $this->path = $path;
        if (is_file($this->path)) {
            $this->handle = @fopen($this->path, 'r+b');
        } else {
            $this->handle = @fopen($this->path, 'w+b');
        }
        if (!is_resource($this->handle)) {
            throw new Exception("Failed to open state file {$this->path}");
        }
        if (@flock($this->handle, LOCK_EX | LOCK_NB) !== true) {
            throw new Exception("Failed to lock state file {$this->path}");
        }
        $this->locked = true;
    }

    private function close()
    {
        if (is_resource($this->handle)) {
            if ($this->locked) {
                @flock($this->handle, LOCK_UN);
                $this->locked = false;
            }
            @fclose($this->handle);
        }
        $this->handle = null;
        if ($this->delete) {
            @unlink($this->path);
        }
    }

    public function __destruct()
    {
        $this->close();
    }

    public static function write($path, $cldrVersion, array $locales, array $localeFiles, array $supplementalFiles, array $testFiles = [])
    {
        $me = new static($path);
        $json = '';
        while (!feof($me->handle)) {
            $chunk = @fread($me->handle, 4096);
            if ($chunk === false) {
                throw new Exception("Failed to read from state file $path");
            }
            if ($chunk === '') {
                break;
            }
            $json .= $chunk;
        }
        if ($json === '') {
            $state = [
                'formats' => [],
            ];
        } else {
            $state = @json_decode($json, true);
            if (!is_array($state)) {
                throw new Exception("Failed to decode state file $path");
            }
            if (!isset($state['formats'])) {
                $state['formats'] = [];
            } elseif (!is_array($state['formats'])) {
                throw new Exception("Invalid state file $path");
            }
        }
        if (!isset($state['formats'][BuildOptions::FORMAT_VERSION])) {
            $state['formats'][BuildOptions::FORMAT_VERSION] = [];
        }
        if (!isset($state['formats'][BuildOptions::FORMAT_VERSION]['cldr'])) {
            $state['formats'][BuildOptions::FORMAT_VERSION]['cldr'] = [];
        }
        sort($localeFiles);
        sort($supplementalFiles);
        $state['formats'][BuildOptions::FORMAT_VERSION]['cldr'][$cldrVersion] = [
            'locales' => $locales,
            'localeFiles' => array_map('basename', $localeFiles),
            'supplementalFiles' => array_map('basename', $supplementalFiles),
        ];
        if (count($testFiles) > 0) {
            sort($testFiles);
            $state['formats'][BuildOptions::FORMAT_VERSION]['cldr'][$cldrVersion]['testFiles'] = array_map('basename', $testFiles);
        }
        $json = json_encode($state, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        if ($json === false) {
            throw new Exception("Failed to encode state file $path");
        }
        if (@ftruncate($me->handle, 0) === false) {
            throw new Exception("Failed to reset state file $path");
        }
        $me->delete = true;
        if (@rewind($me->handle) === false) {
            throw new Exception("Failed to reset state file $path");
        }
        $bytes = strlen($json);
        if (@fwrite($me->handle, $json) !== $bytes) {
            throw new Exception("Failed to write state file $path");
        }
        $me->delete = false;
        @fflush($me->handle);
        $me->close();
    }
}

class CldrDraftStatus
{
    /**
     * Draft status: unconfirmed.
     *
     * @var string
     */
    const LEVEL_UNCONFIRMED = 'unconfirmed';

    /**
     * Draft status: provisional.
     *
     * @var string
     */
    const LEVEL_PROVISIONAL = 'provisional';

    /**
     * Draft status: contributed.
     *
     * @var string
     */
    const LEVEL_CONTRIBUTED = 'contributed';

    /**
     * Draft status: approved.
     *
     * @var string
     */
    const LEVEL_APPROVED = 'approved';

    /**
     * Get all the available statuses.
     *
     * @return string[]
     */
    public static function getAllStatuses()
    {
        return [
            self::LEVEL_UNCONFIRMED,
            self::LEVEL_PROVISIONAL,
            self::LEVEL_CONTRIBUTED,
            self::LEVEL_APPROVED,
        ];
    }
}
